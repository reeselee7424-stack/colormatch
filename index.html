<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æ±½æ°´é…å¯¹å·¥å‚</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#4a3b32">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <style>
    :root{
      --text: #f3f4f6;
      --wood-dark: #3e2723;
      --wood-light: #5d4037;
      --wood-shadow: rgba(0,0,0,0.5);
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family: system-ui, sans-serif;
      color:var(--text);
      overflow:hidden;
      background: #2b2b2b; /* æ·±è‰²èƒŒæ™¯è¡¬æ‰˜æœ¨çº¹ */
    }

    /* ===== èƒŒæ™¯è£…é¥°ï¼ˆç®€åŒ–ï¼‰ ===== */
    .bg-texture{
      position:fixed; inset:0; z-index:0; pointer-events:none;
      background: radial-gradient(circle at 50% 30%, #4a4a4a, #1a1a1a);
    }

    /* ===== ä¸»ç•Œé¢å¸ƒå±€ ===== */
    .wrap{ 
      width: min(1000px, 96vw); 
      height: 90vh;
      position:relative; 
      z-index:1; 
      display: flex;
      flex-direction: column;
    }

    header{
      display:flex; justify-content:space-between; align-items:center;
      padding-bottom: 10px;
    }
    h1{ margin:0; font-size:20px; color: #fbbf24; text-shadow: 2px 2px 0 #000; }
    
    .meta{ display:flex; gap:10px; font-size:14px; align-items:center; }
    .btn{
      background: #5d4037;
      color: #fff;
      border: 1px solid #795548;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .btn:active { transform: translateY(2px); }

    /* ===== æ ¸å¿ƒä¸¤æ å¸ƒå±€ ===== */
    .game-board {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 100px; /* å·¦ä¾§é…å¯¹åŒº(å®½)ï¼Œå³ä¾§è´§æ¶(çª„) */
      gap: 16px;
      overflow: hidden; /* å†…éƒ¨æ»šåŠ¨ */
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 12px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
    }

    /* --- å·¦åˆ—ï¼šå°è¯•è®°å½•åŒº --- */
    .history-column {
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .history-column::-webkit-scrollbar { width: 6px; }
    .history-column::-webkit-scrollbar-thumb { background: #666; border-radius: 4px; }

    /* --- å³åˆ—ï¼šæ±½æ°´è´§æ¶ --- */
    .shelf-column {
      background: #3e2723;
      border: 4px solid #281a16;
      border-radius: 8px;
      padding: 10px 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      overflow-y: auto;
      box-shadow: inset 0 0 10px #000;
    }

    /* ===== æœ¨è´¨è¡Œ (Row) ===== */
    .rowCard{
      background: url('data:image/svg+xml;utf8,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><rect width="100" height="100" fill="%235d4037"/><path d="M0 0h100v2H0z" fill="%23795548" opacity=".5"/></svg>');
      background-size: cover;
      border: 2px solid #3e2723;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }
    .rowCard.active {
      border-color: #fbbf24;
      box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
    }

    .slots{
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    /* ===== æœ¨æ ¼å­ (Grid) ===== */
    .cup {
      width: 50px; height: 80px; /* é€‚åˆç“¶å­çš„é«˜ç˜¦æ¯”ä¾‹ */
      background: #2e1e1a;
      border-radius: 4px;
      position: relative;
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.1);
      border: 1px solid #4e342e;
      display: flex;
      justify-content: center;
      align-items: flex-end; /* ç“¶å­æ”¾åœ¨åº•éƒ¨ */
    }
    .cup.dropHover { background: #4a342e; outline: 2px dashed #fbbf24; }

    /* ===== æ±½æ°´ç“¶ (Bottle) ===== */
    .candy {
      width: 32px; height: 70px; /* ç“¶èº« */
      position: relative;
      border-radius: 4px 4px 8px 8px;
      /* ç»ç’ƒè´¨æ„Ÿ */
      box-shadow: 
        inset -2px 0 4px rgba(0,0,0,0.3),
        inset 2px 0 4px rgba(255,255,255,0.3),
        0 4px 4px rgba(0,0,0,0.3);
      z-index: 10;
      cursor: grab;
      touch-action: none;
    }
    .candy:active { cursor: grabbing; }

    /* ç“¶é¢ˆ */
    .candy::before {
      content: "";
      position: absolute;
      top: -12px; left: 50%; transform: translateX(-50%);
      width: 14px; height: 12px;
      background: inherit;
      opacity: 0.8;
      border: 1px solid rgba(255,255,255,0.2);
    }
    /* ç“¶ç›– */
    .candy::after {
      content: "";
      position: absolute;
      top: -16px; left: 50%; transform: translateX(-50%);
      width: 18px; height: 4px;
      background: #ccc;
      border-radius: 2px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    /* ç“¶å­æ”¾åœ¨æ¯å­é‡Œæ—¶çš„å¾®è°ƒ */
    .cupCandy {
      position: absolute;
      bottom: 4px; left: 50%; transform: translateX(-50%);
      cursor: default;
    }

    /* ===== çˆ†ç‚¸æ®‹ç•™ (Residue / Stain) ===== */
    .cup .residue {
      position: absolute;
      inset: 0;
      background: var(--residue);
      mask-image: radial-gradient(circle, black 40%, transparent 70%);
      -webkit-mask-image: radial-gradient(circle, black 40%, transparent 70%);
      opacity: 0.8;
      filter: blur(2px);
      z-index: 5;
      animation: splat 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes splat {
      0% { transform: scale(0); opacity: 0; }
      100% { transform: scale(1); opacity: 0.8; }
    }

    /* é”™è¯¯/æ­£ç¡®çŠ¶æ€çš„æ ¼å­è¾¹æ¡†æç¤º */
    .cup.isWrong { border: 2px solid #ef4444; }
    .cup.isCorrect { border: 2px solid #22c55e; }
    
    /* è´§æ¶ä¸Šçš„ç“¶å­ */
    .paletteItem { margin-top: 10px; }
    .used { opacity: 0.3; filter: grayscale(1); }

  </style>
</head>

<body>
  <div class="bg-texture"></div>

  <audio id="bg-soda" preload="auto" loop></audio>
  <audio id="sfx-pop" preload="auto"></audio>
  <audio id="sfx-correct" preload="auto"></audio>

  <div class="wrap">
    <header>
      <div>
        <h1>ğŸ­ æ±½æ°´å·¥å‚</h1>
        <div class="meta">
          <span>å…³å¡: <b id="level">1</b></span>
          <button class="btn" id="soundBtn">ğŸ”‡</button>
        </div>
      </div>
      <div style="text-align:right">
        <button class="btn" id="resetLevel" style="font-size:12px">é‡ç½®æœ¬å…³</button>
        <button class="btn" id="restart" style="font-size:12px;background:#c62828">é‡æ–°å¼€å§‹</button>
      </div>
    </header>

    <div class="game-board">
      <div class="history-column" id="attempts"></div>
      
      <div class="shelf-column" id="palette"></div>
    </div>
  </div>

<script>
(() => {
  /* ===== åˆå§‹åŒ–ä¸é…ç½® ===== */
  const bgSoda = document.getElementById("bg-soda");
  const sfxPop = document.getElementById("sfx-pop");
  const sfxCorrect = document.getElementById("sfx-correct");
  
  bgSoda.src = "soda.mp3";
  sfxPop.src = "pop.mp3";
  sfxCorrect.src = "correct.mp3";
  
  const VOLUME = { bg: 0.15, pop: 0.15, correct: 0.3 };
  let soundOn = false;

  const COLOR_POOL = [
    {name:"å¯ä¹çº¢", hex:"#b91c1c"}, // Red
    {name:"èŠ¬è¾¾æ©™", hex:"#ea580c"}, // Orange
    {name:"æŸ æª¬é»„", hex:"#eab308"}, // Yellow
    {name:"é›ªç¢§ç»¿", hex:"#15803d"}, // Green
    {name:"æµ·ç›é’", hex:"#06b6d4"}, // Cyan
    {name:"ç™¾äº‹è“", hex:"#1e40af"}, // Blue
    {name:"è‘¡è„ç´«", hex:"#7e22ce"}, // Purple
    {name:"æ¡ƒå­ç²‰", hex:"#be185d"}, // Pink
    {name:"å’–å•¡æ£•", hex:"#451a03"}, // Brown
  ];

  /* ===== è®°å¿†åŠŸèƒ½ (LocalStorage) ===== */
  const SAVE_KEY = "soda_match_save_v1";

  function saveGame() {
    const state = {
      level, pairCount, ids, correctSeq, attempts, activeRowIndex
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(state));
  }

  function loadGame() {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return false;
    try {
      const state = JSON.parse(raw);
      level = state.level || 1;
      pairCount = state.pairCount || 3;
      ids = state.ids || [];
      correctSeq = state.correctSeq || [];
      attempts = state.attempts || [];
      activeRowIndex = state.activeRowIndex || 0;
      
      // ç®€å•çš„æ ¡éªŒï¼Œé˜²æ­¢åæ¡£
      if (!attempts.length || !ids.length) return false;
      return true;
    } catch(e) {
      console.error("Save file corrupted", e);
      return false;
    }
  }

  /* ===== æ¸¸æˆé€»è¾‘å˜é‡ ===== */
  let level = 1;
  let pairCount = 3;
  let ids = [];
  let correctSeq = [];
  let attempts = [];
  let activeRowIndex = 0;
  
  let draggingColorId = null;
  let touchHoverCup = null;

  /* ===== æ ¸å¿ƒé€»è¾‘å‡½æ•° ===== */
  const shuffle = (arr) => arr.sort(() => Math.random() - 0.5);

  function pairsForLevel(lvl){
    if (lvl === 1) return 3;
    const base = 4 + Math.floor((lvl - 2) / 3);
    return Math.min(base, 9); // ä¸Šé™9ä¸ª
  }

  function setupLevel(isNew = true){
    if (isNew) {
      pairCount = pairsForLevel(level);
      const allIds = COLOR_POOL.map((_, i) => i);
      ids = shuffle(allIds).slice(0, pairCount);
      correctSeq = shuffle([...ids]); // éšæœºç­”æ¡ˆåºåˆ—

      attempts = [{
        guess: Array(pairCount).fill(null),
        status: "active",
        residue: Array(pairCount).fill(null), // è®°å½•çˆ†ç‚¸æ±¡æ¸é¢œè‰²
      }];
      activeRowIndex = 0;
    }
    saveGame();
    renderAll();
  }

  function placeColor(rowIdx, cupIdx, colorId){
    const row = attempts[rowIdx];
    if (!row || row.status !== "active") return;

    // å¦‚æœè¿™ä¸ªé¢œè‰²å·²ç»åœ¨åˆ«çš„åœ°æ–¹ï¼Œå…ˆæ¸…ç©ºæ—§ä½ç½®
    const prevPos = row.guess.findIndex(v => v === colorId);
    if (prevPos !== -1 && prevPos !== cupIdx){
      row.guess[prevPos] = null;
    }
    
    row.guess[cupIdx] = colorId;
    saveGame(); // æ¯æ¬¡æ“ä½œéƒ½ä¿å­˜
    renderAll();

    // æ£€æŸ¥æ˜¯å¦å¡«æ»¡
    if (row.guess.every(v => v !== null)){
      checkRow(row);
    }
  }

  function checkRow(row){
    const marks = row.guess.map((id, i) => id === correctSeq[i]);
    const allCorrect = marks.every(Boolean);

    row.marks = marks;
    row.status = allCorrect ? "ok" : "bad";

    if (!allCorrect) {
      // âŒ é”™è¯¯ï¼šè®¡ç®—æ®‹ç•™é¢œè‰²ï¼Œç„¶åç§»é™¤ç“¶å­
      // é€»è¾‘ï¼šå¦‚æœè¿™ä¸ªæ ¼å­é”™äº†ï¼Œè®°å½•ä¸‹å½“å‰ç“¶å­çš„é¢œè‰²ä½œä¸ºæ±¡æ¸ï¼Œæ˜¾ç¤ºçˆ†ç‚¸æ•ˆæœ
      row.residue = row.guess.map((id, i) => marks[i] ? null : COLOR_POOL[id].hex);
      playOne(sfxPop);
    } else {
      playOne(sfxCorrect);
    }

    saveGame();
    renderAll();

    if (allCorrect) {
      setTimeout(() => {
        level++;
        setupLevel(true);
      }, 1000);
    } else {
      setTimeout(() => {
        // æ–°å¢ä¸€è¡Œ
        attempts.push({
          guess: Array(pairCount).fill(null),
          status: "active",
          residue: Array(pairCount).fill(null),
        });
        activeRowIndex++;
        saveGame();
        renderAll();
        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        document.getElementById("attempts").scrollTop = 9999;
      }, 600);
    }
  }

  /* ===== æ¸²æŸ“ DOM ===== */
  const elAttempts = document.getElementById("attempts");
  const elPalette = document.getElementById("palette");

  function makeCandy(colorId, isCup){
    const c = COLOR_POOL[colorId];
    const d = document.createElement("div");
    d.className = "candy";
    if (isCup) d.classList.add("cupCandy");
    d.dataset.cid = colorId;
    d.style.background = `linear-gradient(to right, ${c.hex} 40%, rgba(255,255,255,0.2) 90%)`;
    d.style.backgroundColor = c.hex;
    
    if (!isCup) {
      d.draggable = true;
      d.addEventListener("dragstart", e => {
        draggingColorId = colorId;
        e.dataTransfer.setData("text/plain", colorId);
      });
      // è§¦æ‘¸æ”¯æŒ
      d.addEventListener("touchstart", e => {
        draggingColorId = colorId;
      }, {passive: true});
    }
    return d;
  }

  function renderPalette(){
    elPalette.innerHTML = "";
    const activeRow = attempts[activeRowIndex];
    const usedIds = new Set(activeRow ? activeRow.guess.filter(x => x!==null) : []);

    ids.forEach(id => {
      const wrap = document.createElement("div");
      wrap.className = "paletteItem";
      const b = makeCandy(id, false);
      if (usedIds.has(id)) b.classList.add("used");
      wrap.appendChild(b);
      elPalette.appendChild(wrap);
    });
  }

  function renderAttempts(){
    elAttempts.innerHTML = "";
    attempts.forEach((row, rIdx) => {
      const rowDiv = document.createElement("div");
      rowDiv.className = "rowCard" + (rIdx === activeRowIndex ? " active" : "");
      
      const slotDiv = document.createElement("div");
      slotDiv.className = "slots";

      for(let i=0; i<pairCount; i++){
        const cup = document.createElement("div");
        cup.className = "cup";
        
        // æ˜¾ç¤ºæ±¡æ¸ (é”™è¯¯åçš„çˆ†ç‚¸ç—•è¿¹)
        if (row.residue && row.residue[i]) {
           const splat = document.createElement("div");
           splat.className = "residue";
           splat.style.setProperty("--residue", row.residue[i]);
           cup.appendChild(splat);
           cup.classList.add("isWrong");
        }

        // æ˜¾ç¤ºç“¶å­
        const contentId = row.guess[i];
        if (contentId !== null) {
          // å¦‚æœè¿™è¡Œå·²ç»åˆ¤å®šä¸”é”™è¯¯ï¼Œç“¶å­åº”è¯¥â€œçˆ†å¼€æ¶ˆå¤±â€
          // ä½†ä¸ºäº†æ˜¾ç¤ºæ•ˆæœï¼Œæˆ‘ä»¬åªç§»é™¤é”™è¯¯çš„ç“¶å­ï¼Œä¿ç•™æ­£ç¡®çš„ç“¶å­
          const isFinished = row.status !== "active";
          const isCorrectSlot = row.marks && row.marks[i];
          
          if (!isFinished || isCorrectSlot) {
             const bottle = makeCandy(contentId, true);
             cup.appendChild(bottle);
             if (isFinished && isCorrectSlot) cup.classList.add("isCorrect");
          }
        }

        // æ‹–æ”¾äº‹ä»¶ (ä»…å½“å‰è¡Œæœ‰æ•ˆ)
        if (row.status === "active") {
          cup.addEventListener("dragover", e => { e.preventDefault(); cup.classList.add("dropHover"); });
          cup.addEventListener("dragleave", () => cup.classList.remove("dropHover"));
          cup.addEventListener("drop", e => {
            e.preventDefault();
            cup.classList.remove("dropHover");
            const cid = parseInt(e.dataTransfer.getData("text/plain"));
            if (!isNaN(cid)) placeColor(rIdx, i, cid);
          });
          
          // è§¦æ‘¸æ”¾ç½®è¾…åŠ©
          cup.dataset.r = rIdx; cup.dataset.c = i;
        }

        slotDiv.appendChild(cup);
      }
      rowDiv.appendChild(slotDiv);
      elAttempts.appendChild(rowDiv);
    });
  }

  function renderAll(){
    document.getElementById("level").innerText = level;
    renderPalette();
    renderAttempts();
  }

  /* ===== å£°éŸ³æ§åˆ¶ ===== */
  const soundBtn = document.getElementById("soundBtn");
  soundBtn.onclick = () => {
    soundOn = !soundOn;
    soundBtn.innerText = soundOn ? "ğŸ”Š" : "ğŸ”‡";
    bgSoda.volume = soundOn ? VOLUME.bg : 0;
    if(soundOn) bgSoda.play().catch(()=>{});
  };

  function playOne(audio){
    if(!soundOn) return;
    audio.currentTime = 0;
    audio.play().catch(()=>{});
  }

  /* ===== å…¨å±€è§¦æ‘¸é€»è¾‘ (Drag & Drop fix for mobile) ===== */
  document.addEventListener("touchend", e => {
    if (draggingColorId === null) return;
    const t = e.changedTouches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    const cup = el ? el.closest(".cup") : null;
    
    if (cup && cup.dataset.r) {
      placeColor(parseInt(cup.dataset.r), parseInt(cup.dataset.c), draggingColorId);
    }
    draggingColorId = null;
    // ç§»é™¤æ‰€æœ‰é«˜äº®
    document.querySelectorAll(".dropHover").forEach(c => c.classList.remove("dropHover"));
  });

  document.addEventListener("touchmove", e => {
    if (draggingColorId === null) return;
    e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
    const t = e.touches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    const cup = el ? el.closest(".cup") : null;
    
    document.querySelectorAll(".dropHover").forEach(c => c.classList.remove("dropHover"));
    if (cup && cup.dataset.r) cup.classList.add("dropHover");
  }, {passive: false});

  /* ===== å¯åŠ¨ ===== */
  document.getElementById("resetLevel").onclick = () => setupLevel(true);
  document.getElementById("restart").onclick = () => {
    localStorage.removeItem(SAVE_KEY);
    level = 1; 
    setupLevel(true);
  };

  // å°è¯•åŠ è½½å­˜æ¡£ï¼Œæ²¡æœ‰åˆ™æ–°å¼€
  if (!loadGame()) {
    setupLevel(true);
  } else {
    renderAll();
  }

})();
</script>
</body>
</html>
