<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æœæ±è½¯ç³– - 3Dæå…‰ç‰ˆ</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0f172a">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root{
      --text: #e2e8f0;
      /* åŠ¨æ€å˜é‡ */
      --cup-sz: 50px; 
    }

    body{
      margin:0; height:100vh; display:flex; justify-content:center;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color:var(--text); overflow:hidden; overscroll-behavior: none;
      /* 1. èƒŒæ™¯ä¿®æ”¹ï¼šæ·±é‚ƒçš„è“é»‘æ¸å˜ï¼Œæ¨¡æ‹Ÿå›¾äºŒçš„æ°›å›´ */
      background: radial-gradient(circle at 50% 0%, #1e293b 0%, #020617 100%);
    }

    /* æ°›å›´å…‰ç‚¹ï¼ˆå¯é€‰ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿï¼‰ */
    .glow-spot {
      position: fixed; width: 600px; height: 600px;
      background: radial-gradient(circle, rgba(56, 189, 248, 0.03) 0%, transparent 70%);
      top: -200px; left: 50%; transform: translateX(-50%);
      pointer-events: none; z-index: 0;
    }

    .app-container {
      width: 100%; max-width: 460px; height: 100%;
      position: relative; display: flex; flex-direction: column; z-index: 1;
      /* æ•´ä½“å®¹å™¨å¢åŠ ä¸€ç‚¹ç‚¹å…‰æ³½ */
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
    }

    header{
      padding: 14px 20px; display:flex; justify-content:space-between; align-items:center;
      background: rgba(15, 23, 42, 0.6); 
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,0.05);
      z-index: 10;
    }
    h1{ margin:0; font-size:16px; font-weight: 600; letter-spacing: 1px; color: #94a3b8; }
    .status-bar{ font-size:13px; color: #64748b; display:flex; gap:12px; font-variant-numeric: tabular-nums;}
    .status-bar span { color:#f8fafc; font-weight: 500;}

    .controls { 
      display: flex; gap: 8px; padding: 10px 20px; justify-content: flex-end; 
      background: rgba(2, 6, 23, 0.3);
    }
    .btn{
      background: rgba(30, 41, 59, 0.5); color:#cbd5e1; 
      border:1px solid rgba(255,255,255,0.1);
      padding: 6px 14px; border-radius: 20px; font-size: 12px; cursor: pointer;
      transition: all 0.2s;
    }
    .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }

    .game-area { flex: 1; overflow: hidden; display: flex; flex-direction: column; padding: 10px 0; }
    .attempts-scroll {
        flex: 1; overflow-y: auto; padding: 10px 16px;
        display: flex; flex-direction: column; gap: 12px;
        scroll-behavior: smooth;
        /* éšè—æ»šåŠ¨æ¡ */
        scrollbar-width: none;
    }
    .attempts-scroll::-webkit-scrollbar { display: none; }
    
    .row-card{
      display: flex; justify-content: center; padding: 12px;
      border-radius: 16px; 
      /* 2. å®¹å™¨ä¿®æ”¹ï¼šæ·±è‰²ç»ç’ƒæ‰˜ç›˜æ„Ÿ */
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      flex-shrink: 0;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    .row-card.active{
      /* å½“å‰è¡Œé«˜äº®ï¼šæ›´æ˜æ˜¾çš„è¾¹æ¡†å…‰æ³½ */
      background: rgba(30, 41, 59, 0.4);
      border-color: rgba(56, 189, 248, 0.3);
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.1);
      transform: scale(1.02);
    }

    .slots{ display:grid; gap: 8px; grid-template-columns: repeat(var(--count), var(--cup-sz)); }

    /* ===== 3. æ¯å­ (Slots) ä¿®æ”¹ï¼šå†…å‡¹å­”æ´æ•ˆæœ ===== */
    .cup{
      width: var(--cup-sz); height: var(--cup-sz); /* æ­£åœ† */
      border-radius: 50%; position:relative; 
      /* å†…é˜´å½±åˆ¶é€ å‡¹é™·æ„Ÿ */
      background: rgba(0,0,0,0.3);
      box-shadow: 
        inset 0 2px 5px rgba(0,0,0,0.6), /* é¡¶éƒ¨æ·±å½± */
        inset 0 -1px 1px rgba(255,255,255,0.1), /* åº•éƒ¨å¾®åå…‰ */
        0 1px 0 rgba(255,255,255,0.05); /* å¤–éƒ¨ä¸‹è¾¹ç¼˜é«˜å…‰ */
      border: none;
    }
    .cup.dropHover{ 
      box-shadow: inset 0 0 10px rgba(56, 189, 248, 0.5); 
    }

    /* æ®‹ç•™å±‚ */
    .residue-layer {
      position: absolute; inset: 0; 
      background: var(--c); opacity: 0.3;
      border-radius: 50%; z-index: 1; pointer-events: none;
      filter: blur(4px);
      transform: scale(0.6);
    }

    /* ===== 4. è½¯ç³– (Candy) ä¿®æ”¹ï¼šé«˜å…‰3Dç å­ ===== */
    .candy{
      /* ç¨å¾®æ¯”æ¯å­å°ä¸€ç‚¹ï¼Œç•™å‡ºè¾¹ç¼˜ */
      width: 90%; height: 90%;
      border-radius: 50%; position:absolute; left:50%; top:50%;
      transform: translate(-50%, -50%); z-index: 10;
      
      /* æ ¸å¿ƒï¼š3Dçƒä½“æ¸²æŸ“ */
      background: radial-gradient(circle at 35% 35%, 
        rgba(255,255,255,0.8) 0%, /* é«˜å…‰ç‚¹ */
        rgba(255,255,255,0.2) 20%, 
        var(--bg) 50%, 
        #000 100% /* è¾¹ç¼˜æš—éƒ¨ */
      );
      
      /* æŠ•å½±ï¼Œè®©ç å­æµ®èµ·æ¥ */
      box-shadow: 
        0 4px 8px rgba(0,0,0,0.4),
        inset 0 -2px 4px rgba(0,0,0,0.5); /* åº•éƒ¨è‡ªé˜´å½± */
    }

    /* é¢å¤–çš„é¡¶éƒ¨é«˜å…‰ï¼Œå¢åŠ ç»ç’ƒæ„Ÿ */
    .candy::after {
      content: ''; position: absolute;
      top: 15%; left: 15%; width: 25%; height: 15%;
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0));
      filter: blur(1px);
    }

    .candy.fade-out { 
        transition: transform 0.4s, opacity 0.4s;
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 0; 
    }

    /* åº•éƒ¨è°ƒè‰²ç›˜ */
    .palette-area {
      background: rgba(15, 23, 42, 0.95); 
      padding: 15px 0 30px 0; 
      border-top: 1px solid rgba(255,255,255,0.05);
      backdrop-filter: blur(20px);
      box-shadow: 0 -5px 20px rgba(0,0,0,0.3);
      z-index: 20;
    }
    .palette-scroll { display:flex; gap:12px; padding:0 20px; overflow-x:auto; height: 65px; align-items:center; }
    .p-item { width: 52px; height: 52px; flex-shrink: 0; display:flex; justify-content:center; align-items:center; }
    
    .palette-candy { position: relative; left: auto; top: auto; transform: none; width: 100%; height: 100%; }
    .palette-candy.dragging-source { opacity: 0; }
    .candy.used { filter: grayscale(0.8) brightness(0.5); opacity: 0.6; }

    .drag-ghost {
      position: fixed; pointer-events: none; z-index: 9999;
      width: 50px; height: 50px; opacity: 0.9;
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }
  </style>
</head>

<body>
  <div class="glow-spot"></div>

  <div class="app-container">
    <header>
        <h1>ğŸ’ å®çŸ³é…å¯¹</h1>
        <div class="status-bar">
            <div>LEVEL <span id="level" style="color:#38bdf8">1</span></div>
            <div>PAIRS <span id="pairs">3</span></div>
        </div>
    </header>
    
    <div class="controls">
        <button class="btn" id="soundBtn">ğŸ”‡</button>
        <button class="btn" id="resetBtn">â†º é‡ç½®</button>
    </div>

    <div class="game-area">
        <div class="attempts-scroll" id="attempts"></div>
    </div>

    <div class="palette-area">
        <div class="palette-scroll" id="palette"></div>
    </div>
  </div>

<script>
(() => {
  // é¢œè‰²è°ƒæ•´ä¸ºæ›´é²œè‰³çš„è‰²å€¼ï¼Œé…åˆ3Dæ•ˆæœ
  const COLORS = ["#ef4444", "#fb923c", "#facc15", "#4ade80", "#22d3ee", "#3b82f6", "#a855f7", "#f472b6", "#a16207", "#94a3b8", "#84cc16", "#6366f1", "#e11d48", "#15803d"];
  const KEY_SAVE = 'gummy_v7_3d_save';
  
  let state = { level: 1, pairCount: 3, colors: [], answer: [], rows: [], activeRow: 0, sound: true };
  
  /* --- 5. éŸ³é¢‘ç³»ç»Ÿé‡æ„ (Web Audio API) --- */
  // ä½¿ç”¨ Web Audio Context å¯ä»¥å½»åº•è§£å†³ç§»åŠ¨ç«¯å»¶è¿Ÿå’ŒåéŸ³é—®é¢˜
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  let soundBuffers = { pop: null, correct: null };
  
  // æ‡’åŠ è½½éŸ³é¢‘æ–‡ä»¶åˆ°å†…å­˜
  async function loadSound(url) {
    if(!audioCtx) return null;
    try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        return await audioCtx.decodeAudioData(arrayBuffer);
    } catch(e) { console.error('Audio load fail', e); return null; }
  }

  // åˆå§‹åŒ–éŸ³é¢‘ç¯å¢ƒ
  async function initAudio() {
    if (audioCtx) return;
    audioCtx = new AudioContext();
    
    // åŠ è½½éŸ³æ•ˆ
    const [popBuf, correctBuf] = await Promise.all([
        loadSound('pop.mp3'),
        loadSound('correct.mp3') // æ³¨æ„ï¼šæ–‡ä»¶åéœ€ç¡®ä¿æ­£ç¡®ï¼Œä½ çš„åŸä»£ç é‡Œå†™çš„æ˜¯ rightanswer...
    ]);
    soundBuffers.pop = popBuf;
    soundBuffers.correct = correctBuf;
    
    // èƒŒæ™¯éŸ³ä¹ä»ç”¨æ ‡ç­¾ï¼Œå› ä¸ºé•¿éŸ³é¢‘æµå¼æ’­æ”¾æ›´åˆé€‚
    const bgAudio = new Audio('soda.mp3');
    bgAudio.loop = true;
    bgAudio.volume = 0.3;
    window.bgAudio = bgAudio;
  }

  // æ’­æ”¾çŸ­éŸ³æ•ˆ (é›¶å»¶è¿Ÿ)
  function playSfx(name) {
    if (!state.sound || !audioCtx || !soundBuffers[name]) return;
    
    // æ¯æ¬¡æ’­æ”¾å‰å°è¯•æ¢å¤ Context (å¤„ç†æµè§ˆå™¨è‡ªåŠ¨ä¼‘çœ )
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const source = audioCtx.createBufferSource();
    source.buffer = soundBuffers[name];
    source.connect(audioCtx.destination);
    source.start(0);
  }

  // ç”¨æˆ·äº¤äº’è§£é”éŸ³é¢‘
  function unlockAudio() {
    initAudio().then(() => {
        if (state.sound && window.bgAudio) {
            window.bgAudio.play().catch(()=>{});
        }
    });
    document.removeEventListener('touchstart', unlockAudio);
    document.removeEventListener('click', unlockAudio);
  }
  document.addEventListener('touchstart', unlockAudio, {once:true});
  document.addEventListener('click', unlockAudio, {once:true});

  /* --- æ¸¸æˆé€»è¾‘ (ä¿æŒä¸å˜) --- */
  function initGame() {
    const savedLvl = localStorage.getItem(KEY_SAVE);
    state.level = savedLvl ? parseInt(savedLvl) : 1;
    startLevel();
  }
  function getPairCount(lvl) {
    if (lvl > 25) return Math.floor(Math.random() * 6) + 9;
    if (lvl === 1) return 3;
    return Math.min(4 + Math.floor((lvl - 2) / 3), 9);
  }
  function startLevel() {
    state.pairCount = getPairCount(state.level);
    const pool = COLORS.map((_, i) => i).sort(() => Math.random() - 0.5);
    state.colors = pool.slice(0, state.pairCount);
    state.answer = [...state.colors].sort(() => Math.random() - 0.5);
    state.rows = [{ guess: Array(state.pairCount).fill(null), status: 'active', residue: [] }];
    state.activeRow = 0;
    renderUI(); adjustSize();
  }

  function handleGuess(rowIdx, slotIdx, colorId) {
    const row = state.rows[rowIdx];
    if (row.status !== 'active') return;
    const existIdx = row.guess.indexOf(colorId);
    if (existIdx !== -1 && existIdx !== slotIdx) row.guess[existIdx] = null;
    row.guess[slotIdx] = colorId;
    renderBoard();
    if (row.guess.every(c => c !== null)) checkRow(row);
  }

  function checkRow(row) {
    const isCorrect = row.guess.every((c, i) => c === state.answer[i]);
    if (isCorrect) {
        row.status = 'win';
        playSfx('correct'); // ä½¿ç”¨æ–°éŸ³æ•ˆç³»ç»Ÿ
        renderBoard();
        setTimeout(() => { state.level++; localStorage.setItem(KEY_SAVE, state.level); startLevel(); }, 1000);
    } else {
        row.status = 'bad';
        playSfx('pop'); // ä½¿ç”¨æ–°éŸ³æ•ˆç³»ç»Ÿ
        row.guess.forEach((cid, i) => { if (cid !== state.answer[i]) row.residue[i] = COLORS[cid]; });
        renderBoard();
        setTimeout(() => {
            state.rows.push({ guess: Array(state.pairCount).fill(null), status: 'active', residue: [] });
            state.activeRow++;
            renderBoard();
            const el = document.getElementById('attempts'); el.scrollTop = el.scrollHeight;
        }, 500);
    }
  }

  /* --- æ¸²æŸ“ --- */
  function adjustSize() {
    const w = Math.min(window.innerWidth, 460) - 40; 
    let sz = (w - (state.pairCount - 1) * 8) / state.pairCount;
    sz = Math.max(30, Math.min(56, sz)); // ç¨å¾®é™åˆ¶æœ€å¤§å°ºå¯¸
    document.documentElement.style.setProperty('--cup-sz', sz + 'px');
    document.documentElement.style.setProperty('--count', state.pairCount);
  }

  function renderUI() {
    document.getElementById('level').innerText = state.level;
    document.getElementById('pairs').innerText = state.pairCount;
    renderPalette(); renderBoard();
  }

  function renderPalette() {
    const p = document.getElementById('palette'); p.innerHTML = '';
    const activeRow = state.rows[state.activeRow];
    const used = new Set(activeRow ? activeRow.guess : []);
    
    state.colors.forEach(cid => {
        const wrap = document.createElement('div'); wrap.className = 'p-item';
        const c = document.createElement('div'); c.className = 'candy palette-candy';
        c.style.setProperty('--bg', COLORS[cid]);
        if (used.has(cid)) c.classList.add('used');
        c.dataset.cid = cid;
        c.addEventListener('touchstart', (e) => handleTouchStart(e, c, cid), {passive: false});
        wrap.appendChild(c);
        p.appendChild(wrap);
    });
  }

  function renderBoard() {
    const board = document.getElementById('attempts'); board.innerHTML = '';
    state.rows.forEach((row, rIdx) => {
        const card = document.createElement('div');
        card.className = 'row-card' + (rIdx === state.activeRow ? ' active' : '');
        const slots = document.createElement('div'); slots.className = 'slots';
        
        for(let sIdx=0; sIdx<state.pairCount; sIdx++) {
            const cid = row.guess[sIdx];
            const cup = document.createElement('div');
            cup.className = 'cup'; cup.dataset.r = rIdx; cup.dataset.s = sIdx;
            
            if (row.residue[sIdx]) {
                const res = document.createElement('div'); res.className = 'residue-layer';
                res.style.setProperty('--c', row.residue[sIdx]); cup.appendChild(res);
            }
            if (cid !== null) {
                const c = document.createElement('div');
                c.className = (row.status === 'bad' && cid !== state.answer[sIdx]) ? 'candy fade-out' : 'candy';
                c.style.setProperty('--bg', COLORS[cid]); cup.appendChild(c);
            }
            slots.appendChild(cup);
        }
        card.appendChild(slots); board.appendChild(card);
    });
  }

  /* --- äº¤äº’ --- */
  let ghost = null, dragId = null, activeColor = null, hoverCup = null, sourceEl = null;

  function handleTouchStart(e, el, cid) {
    if(el.classList.contains('used')) return;
    e.preventDefault();
    const t = e.changedTouches[0]; 
    dragId = t.identifier; activeColor = cid; sourceEl = el;
    sourceEl.classList.add('dragging-source');

    ghost = el.cloneNode(true);
    ghost.className = 'candy drag-ghost';
    ghost.classList.remove('dragging-source', 'palette-candy');
    ghost.style.setProperty('--bg', COLORS[cid]);
    ghost.style.left = t.clientX + 'px'; ghost.style.top = t.clientY + 'px';
    document.body.appendChild(ghost);
  }

  document.addEventListener('touchmove', (e) => {
    if (!ghost) return;
    const t = Array.from(e.changedTouches).find(x => x.identifier === dragId);
    if (!t) return;
    e.preventDefault();
    ghost.style.left = t.clientX + 'px'; ghost.style.top = t.clientY + 'px';
    
    const elUnder = document.elementFromPoint(t.clientX, t.clientY);
    const cup = elUnder ? elUnder.closest('.cup') : null;
    if (cup && parseInt(cup.dataset.r) === state.activeRow) {
        if (hoverCup !== cup) {
            if (hoverCup) hoverCup.classList.remove('dropHover');
            cup.classList.add('dropHover'); hoverCup = cup;
        }
    } else if (hoverCup) { hoverCup.classList.remove('dropHover'); hoverCup = null; }
  }, {passive: false});

  const endDrag = (e) => {
    if (!ghost) return;
    ghost.remove(); ghost = null; dragId = null;
    if(sourceEl) sourceEl.classList.remove('dragging-source');
    sourceEl = null;

    if (hoverCup) {
        hoverCup.classList.remove('dropHover');
        handleGuess(parseInt(hoverCup.dataset.r), parseInt(hoverCup.dataset.s), activeColor);
        hoverCup = null;
    }
  };
  document.addEventListener('touchend', endDrag);

  document.getElementById('soundBtn').onclick = function() {
    state.sound = !state.sound; this.innerText = state.sound ? 'ğŸ”Š' : 'ğŸ”‡';
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if(window.bgAudio) {
        state.sound ? window.bgAudio.play().catch(()=>{}) : window.bgAudio.pause();
    }
  };
  document.getElementById('resetBtn').onclick = () => startLevel();
  
  window.addEventListener('resize', adjustSize);
  initGame();
})();
</script>
</body>
</html>
