<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>果汁软糖配对</title>
  <style>
    :root{
      --bg:#0f1221;
      --panel:#171a2f;
      --panel2:#111428;
      --text:#e9ecff;
      --muted:#aab0d6;

      /* responsive sizes */
      --cupW: clamp(54px, 9.6vw, 92px);
      --cupH: calc(var(--cupW) * 0.96);
      --candyW: calc(var(--cupW) * 0.86);
      --candyH: calc(var(--cupW) * 0.64);
      --gap: clamp(8px, 1.8vw, 14px);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC","Microsoft Yahei", sans-serif;
      background: radial-gradient(1200px 800px at 30% 10%, #1b1f46, var(--bg));
      color: var(--text);
      min-height: 100vh;
      display:flex;
      justify-content:center;
    }

    .wrap{
      width:min(980px, 100%);
      padding: 12px 12px calc(16px + env(safe-area-inset-bottom));
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .topbar{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 12px;
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap:wrap;
    }

    .title{
      font-weight: 800;
      letter-spacing: .5px;
      margin-right:auto;
    }
    .stat{
      color: var(--muted);
      font-size: 14px;
      display:flex;
      gap:8px;
      align-items:center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.07);
    }
    .stat b{ color: var(--text); font-weight: 800; }

    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      font-weight: 650;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px); }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .panel{
      background: rgba(0,0,0,0.20);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: var(--radius);
      padding: 12px;
    }

    .panel h3{
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--muted);
      letter-spacing:.4px;
    }

    /* cups row */
    .cupsRow{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--cupW), 1fr));
      gap: var(--gap);
      align-items:end;
    }

    .cup{
      width: var(--cupW);
      height: var(--cupH);
      margin: 0 auto;
      position:relative;
      border-radius: 18px 18px 22px 22px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.20), rgba(255,255,255,0.06)),
        radial-gradient(100px 80px at 30% 30%, rgba(255,255,255,0.14), transparent 60%),
        rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      box-shadow:
        0 10px 30px rgba(0,0,0,0.28),
        inset 0 1px 0 rgba(255,255,255,0.18);
      overflow:hidden;
    }

    .cup::after{
      content:"";
      position:absolute;
      left: 10%;
      top: 8%;
      width: 35%;
      height: 70%;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255,255,255,0.22), transparent);
      transform: rotate(8deg);
      pointer-events:none;
    }

    .cupCandy{
      position:absolute;
      left: 8%;
      top: 16%;
      width: var(--candyW);
      height: var(--candyH);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.18),
        0 10px 18px rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 2px 6px rgba(0,0,0,0.35);
      user-select:none;
      touch-action:none;
    }

    .cupCandy.dragging{
      opacity: .75;
      transform: scale(1.04);
    }

    .cup.dropTarget{
      outline: 2px solid rgba(255,255,255,0.55);
      outline-offset: 3px;
    }

    /* attempts */
    .attempts{
      display:flex;
      flex-direction:column;
      gap: 10px;
      max-height: min(62vh, 560px);
      overflow:auto;
      padding-right: 6px;
    }

    .row{
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .rowMeta{
      display:flex;
      align-items:center;
      gap:8px;
      color: var(--muted);
      font-size: 13px;
    }
    .pill{
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.18);
      border: 1px solid rgba(255,255,255,0.08);
      color: var(--muted);
    }

    .guessRow{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--cupW), 1fr));
      gap: var(--gap);
      align-items:end;
    }

    .miniCup{
      width: var(--cupW);
      height: var(--cupH);
      margin: 0 auto;
      position:relative;
      border-radius: 18px 18px 22px 22px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.10);
      overflow:hidden;
    }

    .miniCandy{
      position:absolute;
      left: 8%;
      top: 16%;
      width: var(--candyW);
      height: var(--candyH);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.15);
    }

    .markRow{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      align-items:center;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      opacity: .95;
    }
    .dot.correct{ background: rgba(42, 218, 120, 0.95); }
    .dot.misplaced{ background: rgba(255, 201, 66, 0.95); }
    .dot.wrong{ background: rgba(255, 74, 74, 0.90); }

    /* mobile low effects */
    .lowfx .cupCandy,
    .lowfx .miniCandy{
      transition: filter 120ms ease, opacity 120ms ease, transform 120ms ease;
    }
    .blurPop{
      filter: blur(4px) saturate(1.1);
      opacity: .75;
      transform: scale(0.98);
    }

    .hint{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
      margin: 0;
    }

    @media (prefers-reduced-motion: reduce){
      .lowfx{ /* keep lowfx feel */ }
    }
  </style>
</head>
<body>
  <div class="wrap" id="app">
    <div class="topbar">
      <div class="title">果汁软糖配对</div>
      <div class="stat">关卡：<b id="lvl"></b></div>
      <div class="stat">配对：<b id="count"></b></div>
      <div class="stat">尝试：<b id="tries"></b></div>
      <button class="btn" id="soundBtn">声音已开启</button>
      <button class="btn" id="resetBtn">重置本关</button>
      <button class="btn" id="restartBtn">从第1关重开</button>
    </div>

    <div class="grid">
      <div class="panel">
        <h3>当前杯子（拖动软糖到杯子里排列）</h3>
        <div class="cupsRow" id="cupsRow"></div>
        <p class="hint" id="hint"></p>
      </div>

      <div class="panel">
        <h3>尝试记录</h3>
        <div class="attempts" id="attempts"></div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     *  Utilities
     **********************/
    const $ = (sel, el=document) => el.querySelector(sel);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const randInt = (a, b) => Math.floor(Math.random()*(b-a+1))+a;
    const shuffle = (arr) => {
      for(let i=arr.length-1;i>0;i--){
        const j = (Math.random()*(i+1))|0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    };

    /**********************
     *  Audio (no assets)
     **********************/
    let audioCtx = null;
    function beep(type="pop", volume=0.10){
      // avoid starting audio unless user interacted
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const t0 = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        if(type==="pop"){
          o.frequency.setValueAtTime(420, t0);
          o.frequency.exponentialRampToValueAtTime(90, t0+0.06);
          g.gain.setValueAtTime(volume, t0);
          g.gain.exponentialRampToValueAtTime(0.001, t0+0.08);
          o.connect(g); g.connect(audioCtx.destination);
          o.start(t0); o.stop(t0+0.085);
        }else if(type==="ok"){
          o.frequency.setValueAtTime(660, t0);
          o.frequency.exponentialRampToValueAtTime(880, t0+0.08);
          g.gain.setValueAtTime(volume, t0);
          g.gain.exponentialRampToValueAtTime(0.001, t0+0.12);
          o.connect(g); g.connect(audioCtx.destination);
          o.start(t0); o.stop(t0+0.13);
        }else if(type==="win"){
          const o2 = audioCtx.createOscillator();
          const g2 = audioCtx.createGain();
          o2.type="sine";
          o.frequency.setValueAtTime(523, t0);
          o2.frequency.setValueAtTime(784, t0);
          g.gain.setValueAtTime(volume, t0);
          g2.gain.setValueAtTime(volume*0.9, t0);
          g.gain.exponentialRampToValueAtTime(0.001, t0+0.18);
          g2.gain.exponentialRampToValueAtTime(0.001, t0+0.18);
          o.connect(g); o2.connect(g2);
          g.connect(audioCtx.destination); g2.connect(audioCtx.destination);
          o.start(t0); o2.start(t0);
          o.stop(t0+0.20); o2.stop(t0+0.20);
        }
      }catch(_){}
    }

    /**********************
     *  Color palette
     *  - base 9 colors
     *  - extra colors generated with hue-distance constraints
     **********************/
    const BASE_COLORS = [
      "#ff4d4d", "#ff9f1a", "#ffd93d",
      "#2bd9a2", "#2fb8ff", "#3b5bff",
      "#9b5cff", "#ff4fd8", "#9be15d"
    ];

    function hexToRgb(hex){
      const m = hex.replace("#","").trim();
      const v = parseInt(m.length===3 ? m.split("").map(x=>x+x).join("") : m, 16);
      return { r:(v>>16)&255, g:(v>>8)&255, b:v&255 };
    }

    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0,l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h*=60;
      }
      return {h,s,l};
    }

    function hslToHex(h,s,l){
      function hue2rgb(p,q,t){
        if(t<0) t+=1;
        if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3 - t)*6;
        return p;
      }
      let r,g,b;
      if(s===0){ r=g=b=l; }
      else{
        const q = l<0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l-q;
        r = hue2rgb(p,q,(h/360)+1/3);
        g = hue2rgb(p,q,(h/360));
        b = hue2rgb(p,q,(h/360)-1/3);
      }
      const toHex = x => {
        const v = Math.round(x*255);
        return v.toString(16).padStart(2,"0");
      };
      return "#"+toHex(r)+toHex(g)+toHex(b);
    }

    function circularHueDist(a,b){
      const d = Math.abs(a-b)%360;
      return Math.min(d, 360-d);
    }

    function generateDistinctColors(totalNeeded){
      // ensures colors are not too similar to existing ones
      const colors = [...BASE_COLORS];
      if(totalNeeded <= colors.length) return colors.slice(0, totalNeeded);

      // collect existing hues
      const hues = colors.map(c => rgbToHsl(...Object.values(hexToRgb(c))).h);

      // tune these to be "less similar"
      const MIN_HUE_DIST = 22;  // hue separation
      const S_RANGE = [0.72, 0.92];
      const L_RANGE = [0.48, 0.62];

      let guard = 0;
      while(colors.length < totalNeeded && guard++ < 2000){
        const h = randInt(0,359);
        if(hues.some(x => circularHueDist(x,h) < MIN_HUE_DIST)) continue;

        const s = (Math.random()*(S_RANGE[1]-S_RANGE[0])+S_RANGE[0]);
        const l = (Math.random()*(L_RANGE[1]-L_RANGE[0])+L_RANGE[0]);
        const hex = hslToHex(h,s,l);

        // secondary check in RGB space (very cheap) against BASE to avoid near-duplicates
        // (not perfect, but works well visually)
        const {r,g,b} = hexToRgb(hex);
        const tooClose = colors.some(c=>{
          const t = hexToRgb(c);
          const dr=r-t.r, dg=g-t.g, db=b-t.b;
          return (dr*dr+dg*dg+db*db) < 2400; // threshold
        });
        if(tooClose) continue;

        colors.push(hex);
        hues.push(h);
      }
      return colors;
    }

    /**********************
     *  Game State + Persistence
     **********************/
    const STORAGE_KEY = "juiceMatch_v2";
    function loadPersist(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(_){ return null; }
    }
    function savePersist(p){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(p)); }catch(_){}
    }

    const appEl = $("#app");
    const cupsRowEl = $("#cupsRow");
    const attemptsEl = $("#attempts");
    const lvlEl = $("#lvl");
    const countEl = $("#count");
    const triesEl = $("#tries");
    const soundBtn = $("#soundBtn");
    const resetBtn = $("#resetBtn");
    const restartBtn = $("#restartBtn");
    const hintEl = $("#hint");

    const isMobileLike = matchMedia("(pointer: coarse)").matches || matchMedia("(max-width: 520px)").matches;
    if(isMobileLike) appEl.classList.add("lowfx");

    const persist = loadPersist() || {
      level: 1,
      sound: true,
      best: {} // { [level]: minTries }
    };

    let level = clamp(persist.level || 1, 1, 999);
    let soundOn = !!persist.sound;

    // runtime state
    let slotCount = 3;
    let palette = BASE_COLORS.slice();
    let secret = [];       // array of color indices
    let current = [];      // draggable colors (indices)
    let attempts = [];     // each: { guess:[idx], marks:[0/1/2] }
    let draggingIdx = null; // index in current array

    // rendering cache
    let needRender = false;
    function scheduleRender(){
      if(needRender) return;
      needRender = true;
      requestAnimationFrame(()=>{
        needRender = false;
        renderTop();
        renderCups();
      });
    }

    function setSoundUI(){
      soundBtn.textContent = soundOn ? "声音已开启" : "声音已关闭";
    }

    function computeSlotCount(lvl){
      // original: lvl1 => 3, lvl2 => 4 ... up to 9 then stay / but user wants lvl>=22 random 9~14
      if(lvl >= 22) return randInt(9,14);
      return clamp(2 + lvl, 3, 9);
    }

    function startLevel(lvl, keepAttempts=false){
      level = lvl;
      slotCount = computeSlotCount(level);

      // ensure palette size supports up to 14
      palette = generateDistinctColors(14);

      // build secret: choose slotCount colors (no repeat by default; if you want repeats, remove "no repeat")
      const ids = shuffle([...Array(palette.length).keys()]);
      secret = ids.slice(0, slotCount);

      // current draggable list is shuffled version of secret
      current = shuffle(secret.slice());

      if(!keepAttempts) attempts = [];

      // reset drag state
      draggingIdx = null;

      // attempts DOM reset (incremental design: rebuild once per level)
      attemptsEl.replaceChildren();

      // hint
      const best = persist.best?.[String(level)];
      hintEl.textContent =
        isMobileLike
          ? `移动端低特效：错位会“变糊+pop”。第22关起每关随机 9~14 杯。${best ? "本关最佳："+best+" 次" : ""}`
          : `拖动软糖到杯子中排列，提交会自动记录结果。第22关起每关随机 9~14 杯。${best ? "本关最佳："+best+" 次" : ""}`;

      scheduleRender();
      renderAttemptsFull(); // only once per level, and then incremental append on each submit
      persist.level = level;
      persist.sound = soundOn;
      savePersist(persist);
    }

    /**********************
     *  Marking logic (Mastermind-like)
     *  marks: 2 correct pos, 1 correct color wrong pos, 0 wrong
     **********************/
    function gradeGuess(guess){
      const n = secret.length;
      const marks = Array(n).fill(0);
      const secretLeft = secret.slice();
      const guessLeft = guess.slice();

      // exact
      for(let i=0;i<n;i++){
        if(guessLeft[i] === secretLeft[i]){
          marks[i] = 2;
          secretLeft[i] = -1;
          guessLeft[i] = -2;
        }
      }
      // misplaced
      for(let i=0;i<n;i++){
        if(guessLeft[i] < 0) continue;
        const j = secretLeft.indexOf(guessLeft[i]);
        if(j !== -1){
          marks[i] = 1;
          secretLeft[j] = -1;
        }
      }
      return marks;
    }

    function isWin(marks){
      return marks.every(m => m===2);
    }

    /**********************
     *  Rendering
     **********************/
    function renderTop(){
      lvlEl.textContent = String(level);
      countEl.textContent = String(slotCount);
      triesEl.textContent = String(attempts.length);
      setSoundUI();
    }

    function renderCups(){
      // rebuild cups row only when level changes or after shuffle / drag swap
      // small DOM count (<=14), rebuild is fine
      cupsRowEl.replaceChildren();

      for(let i=0;i<slotCount;i++){
        const cup = document.createElement("div");
        cup.className = "cup";
        cup.dataset.pos = String(i);

        const candy = document.createElement("div");
        candy.className = "cupCandy";
        candy.draggable = !isMobileLike; // desktop drag
        candy.dataset.pos = String(i);
        candy.dataset.color = String(current[i]);
        candy.style.background = `linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.06)), ${palette[current[i]]}`;
        candy.textContent = ""; // keep clean

        // desktop drag
        candy.addEventListener("dragstart", (e)=>{
          draggingIdx = i;
          candy.classList.add("dragging");
          e.dataTransfer.setData("text/plain", String(i));
          e.dataTransfer.effectAllowed = "move";
        });
        candy.addEventListener("dragend", ()=>{
          draggingIdx = null;
          candy.classList.remove("dragging");
          [...cupsRowEl.querySelectorAll(".cup")].forEach(x=>x.classList.remove("dropTarget"));
        });

        cup.addEventListener("dragover", (e)=>{
          e.preventDefault();
          cup.classList.add("dropTarget");
        });
        cup.addEventListener("dragleave", ()=>{
          cup.classList.remove("dropTarget");
        });
        cup.addEventListener("drop", (e)=>{
          e.preventDefault();
          cup.classList.remove("dropTarget");
          const from = parseInt(e.dataTransfer.getData("text/plain") || "-1", 10);
          const to = i;
          if(Number.isFinite(from) && from>=0 && from<slotCount && to>=0 && to<slotCount && from!==to){
            [current[from], current[to]] = [current[to], current[from]];
            scheduleRender();
          }
        });

        // touch drag (mobile)
        if(isMobileLike){
          let touchId = null;
          let startX=0, startY=0, ghost=null;
          candy.addEventListener("touchstart", (e)=>{
            const t = e.changedTouches[0];
            touchId = t.identifier;
            startX = t.clientX;
            startY = t.clientY;
            draggingIdx = i;

            // ghost
            ghost = candy.cloneNode(true);
            ghost.style.position = "fixed";
            ghost.style.left = (startX - candy.getBoundingClientRect().width/2) + "px";
            ghost.style.top = (startY - candy.getBoundingClientRect().height/2) + "px";
            ghost.style.zIndex = "9999";
            ghost.style.pointerEvents = "none";
            ghost.style.opacity = "0.85";
            ghost.style.transform = "scale(1.06)";
            document.body.appendChild(ghost);
          }, {passive:true});

          candy.addEventListener("touchmove", (e)=>{
            if(touchId==null) return;
            const t = [...e.changedTouches].find(x=>x.identifier===touchId);
            if(!t) return;

            // move ghost (cheap transform)
            ghost && (ghost.style.left = (t.clientX - ghost.getBoundingClientRect().width/2) + "px");
            ghost && (ghost.style.top  = (t.clientY - ghost.getBoundingClientRect().height/2) + "px");

            // highlight target
            const el = document.elementFromPoint(t.clientX, t.clientY);
            [...cupsRowEl.querySelectorAll(".cup")].forEach(x=>x.classList.remove("dropTarget"));
            const targetCup = el?.closest?.(".cup");
            if(targetCup) targetCup.classList.add("dropTarget");
          }, {passive:true});

          candy.addEventListener("touchend", (e)=>{
            if(touchId==null) return;
            const t = [...e.changedTouches].find(x=>x.identifier===touchId);
            touchId = null;

            [...cupsRowEl.querySelectorAll(".cup")].forEach(x=>x.classList.remove("dropTarget"));

            if(t){
              const el = document.elementFromPoint(t.clientX, t.clientY);
              const targetCup = el?.closest?.(".cup");
              if(targetCup){
                const to = parseInt(targetCup.dataset.pos,10);
                const from = draggingIdx;
                if(from!==null && to!==from && to>=0 && to<slotCount){
                  [current[from], current[to]] = [current[to], current[from]];
                }
              }
            }
            draggingIdx = null;
            ghost && ghost.remove();
            ghost = null;
            scheduleRender();
          }, {passive:true});
        }

        cup.appendChild(candy);
        cupsRowEl.appendChild(cup);
      }

      // submit button (kept close to cups for mobile)
      const actions = document.createElement("div");
      actions.style.marginTop = "10px";
      actions.style.display = "flex";
      actions.style.gap = "10px";
      actions.style.flexWrap = "wrap";

      const submit = document.createElement("button");
      submit.className = "btn";
      submit.textContent = "提交本次排列";
      submit.addEventListener("click", submitGuess);

      const shuffleBtn = document.createElement("button");
      shuffleBtn.className = "btn";
      shuffleBtn.textContent = "随机打乱";
      shuffleBtn.addEventListener("click", ()=>{
        shuffle(current);
        scheduleRender();
      });

      actions.appendChild(submit);
      actions.appendChild(shuffleBtn);
      cupsRowEl.appendChild(actions);
    }

    function renderAttemptsFull(){
      // attempts already cleared on level start; re-add if keepAttempts=true
      for(const a of attempts){
        appendAttemptRow(a);
      }
    }

    function appendAttemptRow(attempt){
      const row = document.createElement("div");
      row.className = "row";

      const meta = document.createElement("div");
      meta.className = "rowMeta";
      meta.innerHTML = `<span class="pill">第 ${attemptsEl.children.length+1} 次</span>`;

      const guessRow = document.createElement("div");
      guessRow.className = "guessRow";

      for(let i=0;i<slotCount;i++){
        const mc = document.createElement("div");
        mc.className = "miniCup";

        const candy = document.createElement("div");
        candy.className = "miniCandy";
        candy.style.background = `linear-gradient(180deg, rgba(255,255,255,0.18), rgba(255,255,255,0.05)), ${palette[attempt.guess[i]]}`;

        mc.appendChild(candy);
        guessRow.appendChild(mc);
      }

      const marks = document.createElement("div");
      marks.className = "markRow";
      for(let i=0;i<slotCount;i++){
        const d = document.createElement("div");
        d.className = "dot " + (attempt.marks[i]===2 ? "correct" : attempt.marks[i]===1 ? "misplaced" : "wrong");
        marks.appendChild(d);
      }

      row.appendChild(meta);
      row.appendChild(guessRow);
      row.appendChild(marks);

      attemptsEl.appendChild(row);
      // keep scroll cheap: only scroll when user submits (not every render)
      attemptsEl.scrollTop = attemptsEl.scrollHeight;
    }

    /**********************
     *  Submit + Effects
     **********************/
    function popBlurOnMobile(){
      if(!isMobileLike) return;
      const candies = [...document.querySelectorAll(".cupCandy")];
      candies.forEach(el=>{
        el.classList.add("blurPop");
        setTimeout(()=>el.classList.remove("blurPop"), 280);
      });
    }

    function submitGuess(){
      const guess = current.slice();
      const marks = gradeGuess(guess);

      attempts.push({guess, marks});
      renderTop();
      appendAttemptRow({guess, marks});

      // sound + lowfx effect
      if(soundOn){
        if(isWin(marks)) beep("win", 0.12);
        else beep("pop", 0.10);
      }
      if(!isWin(marks)) popBlurOnMobile();

      // win -> next level (after short delay)
      if(isWin(marks)){
        const used = attempts.length;
        const key = String(level);
        const best = persist.best[key];
        if(!best || used < best) persist.best[key] = used;
        persist.level = level + 1;
        persist.sound = soundOn;
        savePersist(persist);

        setTimeout(()=>startLevel(level+1), 450);
      }else{
        persist.level = level;
        persist.sound = soundOn;
        savePersist(persist);
      }
    }

    /**********************
     *  Controls
     **********************/
    soundBtn.addEventListener("click", ()=>{
      soundOn = !soundOn;
      persist.sound = soundOn;
      savePersist(persist);
      setSoundUI();
      if(soundOn) beep("ok", 0.08);
    });

    resetBtn.addEventListener("click", ()=>{
      startLevel(level);
    });

    restartBtn.addEventListener("click", ()=>{
      persist.level = 1;
      persist.best = {};
      savePersist(persist);
      startLevel(1);
    });

    /**********************
     *  Init
     **********************/
    setSoundUI();
    startLevel(level);
  </script>
</body>
</html>
