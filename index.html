<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>æ±½æ°´æµæ°´çº¿</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#f0f9ff">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <style>
    :root{
      /* åˆå§‹é»˜è®¤å€¼ï¼Œä¼šè¢«JSåŠ¨æ€è¦†ç›– */
      --slot-h: 60px;
      --slot-gap: 12px;
      --can-w: 38px;
      --can-h: 50px;
      
      /* æµæ°´çº¿é…è‰² */
      --belt-dark: #888;
      --belt-light: #bbb;
      --belt-border: #666;
      --floor-color: #c0c0c0;
      --safety-yellow: #e6b800;
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family: system-ui, -apple-system, sans-serif;
      color: #fff;
      overflow:hidden;
      background-color: var(--floor-color);
      /* âœ¨ åœ°æ¿çº¹ç† */
      background-image: 
        linear-gradient(rgba(255, 255, 255, 0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.3) 1px, transparent 1px);
      background-size: 50px 50px;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    /* ğŸªŸ èƒŒæ™¯çª—æˆ· */
    .factory-windows {
      position: fixed; top: 0; left: 0; right: 0; height: 18vh;
      background: linear-gradient(to bottom, #2c3e50, #4a5c6e);
      z-index: 0;
      display: flex; justify-content: space-evenly; align-items: center;
      padding: 0 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      border-bottom: 6px solid #34495e;
    }
    .window-pane {
      width: 12%; height: 60%;
      background: linear-gradient(135deg, #aaddff 0%, #ffffff 60%, #88ccff 100%);
      border: 4px solid #1a252f;
      box-shadow: inset 0 0 20px rgba(255,255,255,0.9), 0 0 15px rgba(173, 216, 230, 0.8);
      position: relative;
      overflow: hidden;
    }
    .window-pane::after {
      content: ""; position: absolute; inset: -50%;
      background: linear-gradient(45deg, transparent 45%, rgba(255,255,255,0.6) 50%, transparent 55%);
      transform: rotate(30deg);
    }

    .wrap{ 
      width: min(1000px, 98vw); 
      height: 96vh;
      position:relative; 
      z-index:1; 
      display: flex;
      flex-direction: column;
      gap: 10px; /* å‡å°æ ‡é¢˜æ ä¸æ¸¸æˆåŒºçš„é—´è· */
      background: transparent; 
      padding-top: 6px;
    }

    /* æ ‡é¢˜æ  */
    .header-bar {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 16px;
      background: rgba(30, 35, 45, 0.75);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      box-shadow: 
        0 8px 32px 0 rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255,255,255,0.1);
      margin-top: 4px;
      flex-shrink: 0; /* é˜²æ­¢è¢«æŒ¤å‹ */
    }
    
    h1 { margin:0; font-size: 16px; font-weight: bold; letter-spacing: 1px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    .meta { display:flex; gap:12px; font-size:12px; color:#ddd; font-weight: 500; }
    
    .btn {
      background: linear-gradient(to bottom, #555, #333); color: #fff;
      border: 1px solid #666; border-bottom: 2px solid #111;
      padding: 4px 10px; border-radius: 6px; font-size: 12px; cursor: pointer;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.1s;
    }
    .btn:active { transform:translateY(2px); border-bottom-width:1px; }
    #restart { background: linear-gradient(to bottom, #d32f2f, #9a0007); border-color: #ef5350; }

    /* æ¸¸æˆé¢æ¿ */
    .game-board {
      flex: 1;
      display: grid;
      /* è°ƒæ•´å³ä¾§è´§æ¶å®½åº¦ï¼Œéšç“¶å­å¤§å°åŠ¨æ€å¾®è°ƒ */
      grid-template-columns: 1fr 90px; 
      gap: 16px;
      overflow: hidden; 
      background: rgba(255, 255, 255, 0.65); 
      border-radius: 16px;
      box-shadow: 
        0 20px 50px rgba(0,0,0,0.2),
        inset 0 0 0 1px rgba(255,255,255,0.4);
      padding: 10px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    /* å·¦ä¾§æµæ°´çº¿ */
    .history-viewport {
      display: flex;
      flex-direction: row;
      /* âœ… å¢åŠ æ¨ªå‘é—´è·ï¼Œé˜²æ­¢æŒ¤åœ¨ä¸€èµ· */
      gap: 30px; 
      overflow-x: auto;
      overflow-y: hidden;
      align-items: center; 
      justify-content: flex-end; 
      padding: 0 20px;
      
      background-color: rgba(0,0,0,0.05);
      background-image: repeating-linear-gradient(
        to bottom,
        var(--belt-border) 0px, 
        var(--belt-border) 1px,
        var(--belt-light) 1px, 
        var(--belt-light) 4px,
        var(--belt-dark) 4px,
        var(--belt-dark) var(--slot-h),
        var(--belt-border) var(--slot-h),
        var(--belt-border) calc(var(--slot-h) + 1px),
        transparent calc(var(--slot-h) + 1px), 
        transparent calc(var(--slot-h) + var(--slot-gap))
      );
      
      background-position: left center;
      background-repeat: no-repeat;
      background-size: 200% var(--belt-bg-height, 100%); 
      border-top: 4px solid #555;
      border-bottom: 4px solid #555;
      border-radius: 4px;
      box-shadow: inset 0 0 30px rgba(0,0,0,0.3);
    }
    .history-viewport::-webkit-scrollbar { height: 6px; }
    .history-viewport::-webkit-scrollbar-thumb { background: #666; border-radius: 3px; }

    /* å³ä¾§è´§æ¶ */
    .shelf-column {
      background: linear-gradient(135deg, #d1d5db, #9ca3af);
      border: 2px solid #4b5563;
      border-radius: 8px;
      padding: 10px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--slot-gap);
      overflow-y: auto;
      box-shadow: 
        inset 0 0 15px rgba(0,0,0,0.3),
        0 5px 15px rgba(0,0,0,0.2);
    }

    .rowCard {
      display: flex; flex-direction: column;
      gap: var(--slot-gap);
      min-width: calc(var(--can-w) + 10px); /* å®½åº¦éšç“¶å­å¤§å°è‡ªé€‚åº” */
      justify-content: center;
      position: relative;
    }
    .rowCard.active { z-index: 2; }
    .rowCard.active::before {
      content: ""; position: absolute; inset: -6px -6px; 
      border: 3px dashed var(--safety-yellow);
      border-radius: 12px;
      background: rgba(255, 235, 59, 0.1);
      z-index: -1;
      animation: pulseBorder 2s infinite;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.3);
    }
    @keyframes pulseBorder { 50% { opacity: 0.6; border-color: #fff; } }

    .cup {
      width: calc(var(--can-w) + 8px); /* å®½åº¦éšç“¶å­è‡ªé€‚åº” */
      height: var(--slot-h);
      background: rgba(0,0,0,0.15); 
      border-radius: 6px;
      position: relative;
      border: 1px solid rgba(255,255,255,0.15);
      display: flex; justify-content: center; align-items: center; 
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      /* âœ… é™åˆ¶çˆ†ç‚¸èŒƒå›´åœ¨æ¡†å†… */
      overflow: hidden;
    }
    .cup.dropHover { 
      background: rgba(255,255,255,0.7); 
      outline: 2px solid var(--safety-yellow); 
      box-shadow: 0 0 15px var(--safety-yellow);
    }
    .cup.isCorrect { border: 2px solid #22c55e; background: rgba(34,197,94,0.15); }
    .cup.isWrong { 
      border: 2px solid #ffffff; 
      background: rgba(255,255,255,0.2); 
      box-shadow: 0 0 8px rgba(255,255,255,0.6);
    }

    /* æ˜“æ‹‰ç½ */
    .can {
      width: var(--can-w); height: var(--can-h);
      position: relative; z-index: 10;
      background-color: var(--can-color);
      background-image: 
        linear-gradient(90deg, 
          rgba(255,255,255,0.15) 0%, 
          rgba(255,255,255,0.6) 35%, 
          rgba(255,255,255,0.1) 50%,
          rgba(0,0,0,0.15) 100%);
      border-radius: 4px 4px 6px 6px;
      box-shadow: 2px 4px 8px rgba(0,0,0,0.4);
      cursor: pointer;
      transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .can.selected {
      box-shadow: 0 0 0 2px #fff, 0 0 15px var(--safety-yellow);
      transform: scale(1.15); z-index: 20;
    }
    .can::before {
      content: ""; position: absolute; top: -3px; left: 3px; right: 3px; height: 4px;
      background: #e5e7eb; border: 1px solid #9ca3af; border-radius: 2px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    /* åº•éƒ¨æ‰˜ */
    .can::after {
      content: ""; position: absolute; bottom: -3px; left: 3px; right: 3px; height: 4px;
      background: linear-gradient(90deg, #6b7280, #d1d5db 50%, #6b7280);
      border-radius: 0 0 4px 4px;
      box-shadow: 0 1px 1px rgba(0,0,0,0.3); z-index: -1;
    }
    
    /* ğŸ·ï¸ Logo */
    .can-label {
      position: absolute; top: 20%; bottom: 20%; left: 0; right: 0;
      background: transparent; 
      z-index: 2;
      background-image: url('xiaoming.png'); 
      background-size: 85%; 
      background-repeat: no-repeat; 
      background-position: center;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));
    }
    
    /* ğŸ’¥ SVG å°–é”å–·æº…å®¹å™¨ (å›ºå®šç‰ˆ) */
    .residue {
      position: absolute;
      inset: 12%; 
      z-index: 5;
      opacity: 1;
      pointer-events: none;
      mix-blend-mode: normal; 
      transform: scale(var(--scale, 1)) rotate(var(--rot, 0deg));
    }
    
    /* SVG å¡«å…… */
    .residue svg {
      width: 100%; height: 100%;
      fill: var(--residue-color);
      opacity: 0;
    }

    /* åŠ¨ç”» */
    .residue.anim-pop svg {
      animation: splashAnim 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }
    /* é™æ€ */
    .residue.static svg {
      opacity: 1;
      transform: scale(1.1);
    }
    
    @keyframes splashAnim {
      0% { transform: scale(0.2); opacity: 0.8; }
      100% { transform: scale(1.1); opacity: 1; }
    }

    .drag-ghost {
      position: fixed; pointer-events: none !important; z-index: 9999;
      transform: translate(-50%, -50%) scale(1.3) rotate(5deg); opacity: 0.95;
      filter: drop-shadow(0 20px 40px rgba(0,0,0,0.5));
    }
    
    .paletteItem { margin-top: 0; }
    .used .can { opacity: 0.3; filter: grayscale(1); cursor: default; }

  </style>
</head>

<body>
  <div class="factory-windows">
    <div class="window-pane"></div>
    <div class="window-pane"></div>
    <div class="window-pane"></div>
    <div class="window-pane"></div>
  </div>

  <audio id="bg-soda" preload="auto" loop></audio>
  <audio id="sfx-pop" preload="auto"></audio>
  <audio id="sfx-correct" preload="auto"></audio>

  <div class="wrap">
    <div class="header-bar">
      <div>
        <h1>ğŸ­ æ±½æ°´æµæ°´çº¿</h1>
        <div class="meta">
          <span>æ‰¹æ¬¡: <b id="level">1</b></span>
          <button class="btn" id="soundBtn" style="padding: 2px 6px; margin-left: 5px;">ğŸ”‡</button>
        </div>
      </div>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="resetLevel">é‡ç½®</button>
        <button class="btn" id="restart">é‡å¼€</button>
      </div>
    </div>

    <div class="game-board" id="board">
      <div class="history-viewport" id="attempts"></div>
      <div class="shelf-column" id="palette"></div>
    </div>
  </div>

<script>
(() => {
  /* ===== ğŸ¨ é¢œè‰²æ±  ===== */
  const COLOR_POOL = [
    {name:"æ·±çº¢", hex:"#b91c1c"},   
    {name:"äº®æ©™", hex:"#fb923c"},   
    {name:"æŸ æª¬", hex:"#facc15"},
    {name:"è‰ç»¿", hex:"#22c55e"},
    {name:"æµ·ç›", hex:"#06b6d4"},
    {name:"æ·±è“", hex:"#1d4ed8"},
    {name:"è‘¡è„", hex:"#7e22ce"},
    {name:"è§å…‰ç²‰", hex:"#f472b6"}, 
    {name:"æ‹¿é“", hex:"#78350f"},
    /* è¿›é˜¶è‰² */
    {name:"é…·é»‘", hex:"#111827"},   
    {name:"é’›é“¶", hex:"#9ca3af"},   
    {name:"è§å…‰ç»¿", hex:"#a3e635"}, 
    {name:"é›è“", hex:"#312e81"},   
    {name:"åœŸè±ªé‡‘", hex:"#ca8a04"}, 
  ];
  
  const SAVE_KEY = "soda_factory_v29_auto_scale";
  const bgSoda = document.getElementById("bg-soda");
  const sfxPop = document.getElementById("sfx-pop");
  const sfxCorrect = document.getElementById("sfx-correct");
  
  bgSoda.src = "soda.mp3"; sfxPop.src = "pop.mp3"; sfxCorrect.src = "correct.mp3";
  let soundOn = false;

  let level = 1;
  let pairCount = 3;
  let ids = [];
  let correctSeq = [];
  let attempts = [];
  let activeRowIndex = 0;
  let draggingColorId = null;
  let dragGhostEl = null;
  let selectedColorId = null;

  /* ===== ğŸ“ æ™ºèƒ½è‡ªé€‚åº”å¸ƒå±€æ ¸å¿ƒ (Smart Sizing) ===== */
  function updateLayoutDimensions() {
    // 1. è·å–å¯è§†åŒºåŸŸé«˜åº¦ï¼ˆå»æ‰æ ‡é¢˜æ çš„å¤§æ¦‚é«˜åº¦ï¼‰
    const viewportH = document.querySelector('.game-board').clientHeight;
    // é¢„ç•™ä¸€äº›ä¸Šä¸‹å†…è¾¹è·
    const availableH = viewportH - 40; 
    
    // 2. æ ¹æ®ç“¶å­æ•°é‡è®¡ç®—ç†æƒ³é«˜åº¦
    // å‡è®¾ gap å æ¯” 15%
    // totalH = count * (slotH + gap)
    let slotH = Math.floor(availableH / pairCount / 1.15);
    
    // 3. é™åˆ¶æœ€å¤§æœ€å°å€¼ï¼Œé˜²æ­¢è¿‡å¤§æˆ–è¿‡å°
    if (slotH > 65) slotH = 65; // æœ€å¤§é«˜åº¦ï¼ˆ3ä¸ªç“¶å­æ—¶ï¼‰
    if (slotH < 32) slotH = 32; // æœ€å°é«˜åº¦ï¼ˆ14ä¸ªç“¶å­æ—¶çš„æé™ï¼‰
    
    // 4. è®¡ç®—é—´è·å’Œç“¶å­å°ºå¯¸
    const gap = Math.max(4, Math.floor(slotH * 0.18));
    const canH = Math.floor(slotH * 0.85); // ç“¶å­å æ ¼å­çš„ 85% é«˜åº¦
    const canW = Math.floor(canH * 0.65);  // ä¿æŒå®½é«˜æ¯”
    
    // 5. åº”ç”¨åˆ° CSS å˜é‡
    const root = document.documentElement;
    root.style.setProperty('--slot-h', `${slotH}px`);
    root.style.setProperty('--slot-gap', `${gap}px`);
    root.style.setProperty('--can-h', `${canH}px`);
    root.style.setProperty('--can-w', `${canW}px`);
    
    // æ›´æ–°èƒŒæ™¯æ¡çº¹
    const totalContentH = pairCount * (slotH + gap) - gap;
    document.querySelector('.history-viewport').style.setProperty('--belt-bg-height', `${totalContentH}px`);
  }

  // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œå®æ—¶è°ƒæ•´
  window.addEventListener('resize', () => {
    // é˜²æŠ–åŠ¨
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(updateLayoutDimensions, 100);
  });

  /* ===== ğŸ’¥ å°–é”å–·æº… SVG ===== */
  function getSplashSVG() {
    return `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <path d="M50,25 C55,20 65,20 70,30 C75,25 85,30 80,40 C85,45 85,55 80,60 C85,65 75,75 70,70 C65,80 55,80 50,75 C45,80 35,80 30,70 C25,75 15,65 20,60 C15,55 15,45 20,40 C15,30 25,25 30,30 C35,20 45,20 50,25 Z" />
        <circle cx="20" cy="30" r="4" />
        <circle cx="80" cy="30" r="3" />
        <circle cx="15" cy="50" r="3" />
        <circle cx="85" cy="50" r="4" />
        <circle cx="30" cy="80" r="3" />
        <circle cx="70" cy="80" r="3" />
        <circle cx="50" cy="15" r="3" />
      </svg>
    `;
  }

  function saveGame() {
    localStorage.setItem(SAVE_KEY, JSON.stringify({ level, pairCount, ids, correctSeq, attempts, activeRowIndex }));
  }
  function loadGame() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      if (!data.attempts || !data.ids) return false;
      level = data.level; pairCount = data.pairCount; ids = data.ids;
      correctSeq = data.correctSeq; attempts = data.attempts; activeRowIndex = data.activeRowIndex;
      return true;
    } catch(e) { return false; }
  }

  function shuffle(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex != 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
    return array;
  }

  function getLevelConfig(lvl) {
    if (lvl <= 21) {
      const count = 3 + Math.floor((lvl - 1) / 3);
      return { count: count, poolSize: 9 };
    }
    const randomCount = 9 + Math.floor(Math.random() * 6);
    return { count: randomCount, poolSize: 14 };
  }

  function setupLevel(isNew = true) {
    if (isNew) {
      const config = getLevelConfig(level);
      pairCount = config.count;
      
      const currentPool = COLOR_POOL.slice(0, config.poolSize);
      const poolIndices = currentPool.map((_, i) => i);
      
      ids = shuffle([...poolIndices]).slice(0, pairCount);
      correctSeq = shuffle([...ids]);

      attempts = [{
        guess: Array(pairCount).fill(null), status: "active", residue: Array(pairCount).fill(null)
      }];
      activeRowIndex = 0;
      selectedColorId = null;
    }
    
    // åˆå§‹åŒ–æ—¶è®¡ç®—ä¸€æ¬¡å¸ƒå±€
    // ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å·²ç»æ¸²æŸ“ï¼Œèƒ½è·å–åˆ°æ­£ç¡®é«˜åº¦
    setTimeout(updateLayoutDimensions, 0); 
    
    saveGame();
    renderAll();
    setTimeout(scrollToEnd, 100);
  }

  function placeColor(rowIdx, cupIdx, colorId) {
    const row = attempts[rowIdx];
    if (!row || row.status !== "active") return;
    const existIdx = row.guess.indexOf(colorId);
    if (existIdx !== -1 && existIdx !== cupIdx) row.guess[existIdx] = null;
    row.guess[cupIdx] = colorId;
    selectedColorId = null;
    saveGame();
    renderAll();
    if (row.guess.every(v => v !== null)) checkRow(row);
  }

  function checkRow(row) {
    const marks = row.guess.map((id, i) => id === correctSeq[i]);
    const allCorrect = marks.every(Boolean);
    row.marks = marks;
    row.status = allCorrect ? "ok" : "bad";

    if (!allCorrect) {
      row.residue = row.guess.map((id, i) => marks[i] ? null : COLOR_POOL[id].hex);
      
      row.residueSpecs = row.residue.map(() => ({
        rot: Math.floor(Math.random() * 360),
        scale: 0.9 + Math.random() * 0.3
      }));
      
      row.failTime = Date.now(); 
      playSound(sfxPop);
    } else {
      playSound(sfxCorrect);
    }
    saveGame();
    renderAll();
    
    if (allCorrect) {
      setTimeout(() => { level++; setupLevel(true); }, 1200);
    } else {
      setTimeout(() => {
        attempts.push({
          guess: Array(pairCount).fill(null), status: "active", residue: Array(pairCount).fill(null)
        });
        activeRowIndex++;
        saveGame();
        renderAll();
        scrollToEnd(); 
      }, 600);
    }
  }

  const elAttempts = document.getElementById("attempts");
  const elPalette = document.getElementById("palette");

  function scrollToEnd() {
    elAttempts.scrollTo({ left: elAttempts.scrollWidth, behavior: 'smooth' });
  }

  function createCanHTML(colorId) {
    const hex = COLOR_POOL[colorId].hex;
    return `<div class="can" style="--can-color:${hex}"><div class="can-label"></div></div>`;
  }

  function renderPalette() {
    elPalette.innerHTML = "";
    const activeRow = attempts[activeRowIndex];
    const usedIds = new Set(activeRow ? activeRow.guess.filter(x => x !== null) : []);

    ids.forEach(id => {
      const wrap = document.createElement("div");
      wrap.className = "paletteItem";
      if (usedIds.has(id)) wrap.classList.add("used");
      const canDiv = document.createElement("div");
      canDiv.innerHTML = createCanHTML(id);
      const canEl = canDiv.firstElementChild;
      if (selectedColorId === id) canEl.classList.add("selected");
      
      addInteraction(canEl, id, false); 
      
      wrap.appendChild(canEl);
      elPalette.appendChild(wrap);
    });
  }

  function renderAttempts() {
    elAttempts.innerHTML = "";
    attempts.forEach((row, rIdx) => {
      const isLast = rIdx === activeRowIndex;
      const card = document.createElement("div");
      card.className = "rowCard" + (isLast ? " active" : "");
      
      for (let i = 0; i < pairCount; i++) {
        const cup = document.createElement("div");
        cup.className = "cup";
        cup.dataset.r = rIdx;
        cup.dataset.c = i;

        if (isLast && selectedColorId !== null && row.guess[i] === null) {
          cup.style.outline = "2px dashed var(--safety-yellow)";
          cup.style.background = "rgba(255,255,255,0.5)";
        } else {
          cup.style.outline = "";
          cup.style.background = "";
        }

        if (isLast) {
          cup.onclick = () => {
            if (selectedColorId !== null) placeColor(rIdx, i, selectedColorId);
          };
        }

        if (row.residue && row.residue[i]) {
          const s = document.createElement("div");
          s.className = "residue";
          s.style.setProperty("--residue-color", row.residue[i]);
          
          const spec = (row.residueSpecs && row.residueSpecs[i]) || { rot: 0, scale: 1 };
          s.style.setProperty("--rot", spec.rot + "deg");
          s.style.setProperty("--scale", spec.scale);
          
          s.innerHTML = getSplashSVG();
          
          const isFresh = (Date.now() - (row.failTime || 0)) < 800;
          if (isFresh) s.classList.add("anim-pop");
          else s.classList.add("static");

          cup.appendChild(s);
          cup.classList.add("isWrong"); 
        }

        const cid = row.guess[i];
        if (cid !== null) {
          const isCorrect = row.marks && row.marks[i];
          const isFinished = row.status !== "active";
          if (!isFinished || isCorrect) {
            const canWrap = document.createElement("div");
            canWrap.innerHTML = createCanHTML(cid);
            const canEl = canWrap.firstElementChild;
            
            if (isLast) {
              addInteraction(canEl, cid, true); 
            } else {
              canEl.style.cursor = "default";
            }
            
            cup.appendChild(canEl);
            if (isFinished && isCorrect) cup.classList.add("isCorrect");
          }
        }
        card.appendChild(cup);
      }
      elAttempts.appendChild(card);
    });
  }

  function renderAll() {
    document.getElementById("level").innerText = level;
    renderPalette();
    renderAttempts();
  }

  function addInteraction(el, colorId, inGrid) {
    let startX = 0, startY = 0;
    let hasMoved = false;

    const start = (x, y) => {
      startX = x; startY = y; hasMoved = false;
      draggingColorId = colorId;
      setTimeout(() => { if (hasMoved) createGhost(x, y, colorId); }, 50);
    };
    const move = (x, y) => {
      if (Math.abs(x - startX) > 5 || Math.abs(y - startY) > 5) {
        hasMoved = true;
        if (!dragGhostEl) createGhost(x, y, colorId);
        moveGhost(x, y);
        highlightCup(x, y);
      }
    };
    const end = (x, y) => {
      if (hasMoved && dragGhostEl) dropAt(x, y);
      else if (!hasMoved) {
        if (!inGrid) { 
           if (selectedColorId === colorId) selectedColorId = null;
           else { selectedColorId = colorId; playSound(bgSoda); }
        } else {
           selectedColorId = colorId;
        }
        renderAll();
      }
      removeGhost();
    };

    el.addEventListener("touchstart", e => start(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
    el.addEventListener("touchmove", e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    el.addEventListener("touchend", e => end(e.changedTouches[0].clientX, e.changedTouches[0].clientY));
    
    el.addEventListener("mousedown", e => {
      start(e.clientX, e.clientY);
      const onMove = ev => move(ev.clientX, ev.clientY);
      const onUp = ev => { end(ev.clientX, ev.clientY); window.removeEventListener("mousemove", onMove); window.removeEventListener("mouseup", onUp); };
      window.addEventListener("mousemove", onMove); window.addEventListener("mouseup", onUp);
    });
  }

  function createGhost(x, y, cid) {
    if (dragGhostEl) return;
    const div = document.createElement("div");
    div.innerHTML = createCanHTML(cid);
    const ghost = div.firstElementChild;
    ghost.classList.add("drag-ghost");
    document.body.appendChild(ghost);
    dragGhostEl = ghost;
    moveGhost(x, y);
  }
  function moveGhost(x, y) { 
    if (dragGhostEl) { 
      dragGhostEl.style.left = x + "px"; 
      // âœ… å‘ä¸Šåç§» 50pxï¼Œè®©æ‰‹æŒ‡ä¸æŒ¡ä½ç“¶å­
      dragGhostEl.style.top = (y - 50) + "px"; 
    } 
  }
  function removeGhost() { if (dragGhostEl) { dragGhostEl.remove(); dragGhostEl = null; } draggingColorId = null; clearHighlight(); }

  function getClosestActiveCup(x, y) {
    const activeCups = Array.from(document.querySelectorAll('.rowCard.active .cup'));
    let closest = null, min = 100;
    activeCups.forEach(cup => {
      const rect = cup.getBoundingClientRect();
      const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2;
      const d = Math.hypot(x - cx, y - cy);
      if (d < min) { min = d; closest = cup; }
    });
    return closest;
  }
  function highlightCup(x, y) { clearHighlight(); const cup = getClosestActiveCup(x, y); if (cup) cup.classList.add("dropHover"); }
  function clearHighlight() { document.querySelectorAll(".dropHover").forEach(e => e.classList.remove("dropHover")); }
  function dropAt(x, y) { const cup = getClosestActiveCup(x, y); if (cup) placeColor(parseInt(cup.dataset.r), parseInt(cup.dataset.c), draggingColorId); }

  const soundBtn = document.getElementById("soundBtn");
  soundBtn.onclick = () => { soundOn = !soundOn; soundBtn.innerText = soundOn ? "ğŸ”Š" : "ğŸ”‡"; bgSoda.volume = soundOn ? 0.2 : 0; if (soundOn) bgSoda.play().catch(()=>{}); else bgSoda.pause(); };
  function playSound(a) { if (soundOn) { a.currentTime=0; a.play().catch(()=>{}); } }

  document.getElementById("resetLevel").onclick = () => setupLevel(true);
  document.getElementById("restart").onclick = () => { localStorage.removeItem(SAVE_KEY); level = 1; setupLevel(true); };

  if (!loadGame()) setupLevel(true); 
  else { 
    renderAll(); 
    // åŠ è½½å­˜æ¡£åä¹Ÿé‡æ–°è®¡ç®—ä¸€æ¬¡å¸ƒå±€
    setTimeout(updateLayoutDimensions, 0);
    setTimeout(scrollToEnd, 200); 
  }
})();
</script>
</body>
</html>
