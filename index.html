<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æœæ±è½¯ç³–é…å¯¹</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b1330">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    :root{
      --text:#e5e7eb;
      --panel:rgba(17,24,39,.62);
      --blue:rgba(59,130,246,.95);
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Noto Sans CJK SC",sans-serif;
      color:var(--text);
      overflow:hidden;

      background:
        radial-gradient(900px 520px at 35% 10%, rgba(255,255,255,.16), transparent 55%),
        radial-gradient(820px 520px at 75% 15%, rgba(255,255,255,.10), transparent 58%),
        radial-gradient(900px 700px at 50% 110%, rgba(255,255,255,.12), transparent 60%),
        linear-gradient(180deg,#0b1330 0%,#0b2a3a 30%,#0a3a4a 55%,#0a2b43 100%);
    }

    /* ===== èƒŒæ™¯æ³¡æ³¡ ===== */
    .bg-bubbles{ position:fixed; inset:0; pointer-events:none; overflow:hidden; z-index:0; }
    .bubble{
      position:absolute; bottom:-60px; border-radius:50%;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.28), rgba(255,255,255,0) 60%),
        radial-gradient(circle at 55% 65%, rgba(255,255,255,.10), rgba(255,255,255,0) 62%);
      border:1px solid rgba(255,255,255,.18);
      opacity:.55;
      animation: rise var(--dur) linear infinite, sway var(--sway) ease-in-out infinite;
      left: var(--x);
      width: var(--size);
      height: var(--size);
      animation-delay: var(--delay);
    }
    @keyframes rise{ from{ transform: translateY(0); } to{ transform: translateY(-110vh); } }
    @keyframes sway{ 0%,100%{ margin-left:0; } 50%{ margin-left:var(--sx); } }

    /* ===== ä¸»ç•Œé¢ ===== */
    .wrap{ width:min(1040px, 94vw); position:relative; z-index:1; }
    header{
      display:flex; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
      gap:12px; margin-bottom:14px;
    }
    h1{ margin:0; font-size:18px; letter-spacing:.2px; text-shadow:0 10px 30px rgba(0,0,0,.35); }
    .meta{
      display:flex; flex-wrap:wrap; gap:12px;
      color:rgba(226,232,240,.85); font-size:13px; align-items:center;
    }
    .btn{
      background:rgba(31,41,55,.72);
      color:var(--text);
      border:1px solid rgba(148,163,184,.28);
      padding:8px 12px;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 26px rgba(0,0,0,.18);
    }
    .btn:hover{ filter:brightness(1.08); }

    .panel{
      background: var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.38);
      backdrop-filter: blur(10px);
      touch-action: none;
    }

    .grid{ display:grid; grid-template-columns:1fr; gap:16px; }

    .attemptArea{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:14px;
      background: rgba(0,0,0,.10);
    }

    .attempts{
      height: 560px;
      overflow-y:auto;
      display:flex;
      flex-direction:column;
      gap:14px;
      padding-right:6px;
    }

    .rowCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:14px;
      background: rgba(255,255,255,.04);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.04);
    }
    .rowCard.active{
      border-color: rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.06),
        0 10px 28px rgba(0,0,0,.20);
      outline: none;
    }

    .slots{
      display:grid;
      gap:14px;
      justify-items:start;
      align-items:center;
    }
    .slots[data-count="3"]{ grid-template-columns: repeat(3, 90px); }
    .slots[data-count="4"]{ grid-template-columns: repeat(4, 90px); }
    .slots[data-count="5"]{ grid-template-columns: repeat(5, 90px); }
    .slots[data-count="6"]{ grid-template-columns: repeat(6, 90px); }
    .slots[data-count="7"]{ grid-template-columns: repeat(7, 90px); }
    .slots[data-count="8"]{ grid-template-columns: repeat(8, 90px); }
    .slots[data-count="9"]{ grid-template-columns: repeat(9, 90px); }

    /* ===== ç»ç’ƒæ¯ ===== */
    .cup{
      width:90px; height:86px; border-radius:999px;
      position:relative; overflow:hidden;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border: 1px solid rgba(255,255,255,.22);
      box-shadow:
        inset 0 18px 26px rgba(0,0,0,.30),
        inset 0 -18px 30px rgba(255,255,255,.04),
        0 14px 28px rgba(0,0,0,.30);
      backdrop-filter: blur(2px);
    }
    .cup::before{
      content:"";
      position:absolute; inset:8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      opacity:.9; z-index:30; pointer-events:none;
    }
    .cup::after{
      content:"";
      position:absolute; left:10px; top:10px;
      width:28%; height:68%; border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,0));
      opacity:.9; z-index:30; pointer-events:none;
      filter: blur(.2px);
    }
    .cup.dropHover{
      outline:2px solid var(--blue);
      outline-offset:6px;
    }

    /* é”™è¯¯æ®‹ç•™ï¼ˆç•™åœ¨æ¯é‡Œï¼‰ */
    .cup .residue{
      position:absolute;
      inset:12px;
      border-radius:999px;
      background:
        radial-gradient(40% 30% at 30% 35%, rgba(255,255,255,.22), transparent 60%),
        radial-gradient(60% 50% at 65% 60%, rgba(0,0,0,.25), transparent 70%),
        radial-gradient(circle at 50% 65%, var(--residue) 0 55%, transparent 75%);
      opacity:.72;
      filter: blur(1px);
      z-index:4;
      pointer-events:none;
    }

    /* ===== æ¤­åœ†è½¯ç³– ===== */
    .candy{
      width:78px; height:58px; border-radius:999px;
      position:relative; overflow:hidden;
      border:1px solid rgba(255,255,255,.22);
      box-shadow:
        inset 0 10px 16px rgba(255,255,255,.20),
        inset 0 -16px 20px rgba(0,0,0,.18),
        0 10px 18px rgba(0,0,0,.26);
      backdrop-filter: blur(2px);
      transform: translateZ(0);
      user-select:none;
      z-index:10;
    }
    .candy::before{
      content:"";
      position:absolute; left:10px; top:7px;
      width:54%; height:55%;
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), rgba(255,255,255,0) 65%);
      transform: rotate(-12deg);
      opacity:.95; pointer-events:none;
    }
    .candy::after{
      content:"";
      position:absolute; inset:-26px;
      background:
        radial-gradient(circle at 24% 34%, rgba(255,255,255,.16) 0 5px, transparent 6px),
        radial-gradient(circle at 78% 40%, rgba(255,255,255,.12) 0 4px, transparent 5px),
        radial-gradient(circle at 48% 78%, rgba(255,255,255,.10) 0 5px, transparent 6px);
      opacity:.9; pointer-events:none;
    }

    .paletteCandy{ cursor:grab; }
    .paletteCandy:active{ cursor:grabbing; }
    .paletteCandy{ touch-action: none;}
    .used{ opacity:.42; filter:saturate(.7); }
    .cupCandy{ position:absolute; left:6px; top:14px; cursor:default; }

    /* ===== ç³–æœæ± ï¼ˆåªæ˜¾ç¤ºç³–æœæœ¬ä½“ï¼šæ— å¤–æ¡†ã€æ— æ–‡å­—ï¼‰ ===== */
    .paletteCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:14px;
      background: rgba(0,0,0,.10);
    }
    .paletteRow{
      display:flex;
      gap:14px;
      overflow-x:auto;
      padding:6px 2px 0 2px;
    }
    .paletteRow::-webkit-scrollbar{ height:10px; }
    .paletteRow::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.08); border-radius:999px; }

    .paletteItem{
      border:none !important;
      background:transparent !important;
      box-shadow:none !important;
      padding:0 !important;
      min-width:0 !important;
      display:flex;
      align-items:center;
      gap:0;
    }
    .label{ display:none !important; }

    /* ===== çˆ†å¼€åŠ¨ç”» ===== */
    .pop{ animation: pop 260ms ease-out forwards; z-index:12; }
    @keyframes pop{
      0%{ transform: translate(0,0) scale(1); opacity:1; filter:saturate(1) blur(0); }
      60%{ transform: translate(0,-2px) scale(1.06); opacity:.9; filter:saturate(1.2) blur(.2px); }
      100%{ transform: translate(0,6px) scale(.18); opacity:0; filter:saturate(.8) blur(1.2px); }
    }

    .splat{
      position:absolute;
      inset:10px;
      border-radius: 46% 54% 55% 45% / 52% 46% 54% 48%;
      background: var(--splat);
      opacity:.92;
      filter: blur(.3px);
      z-index:6;
      transform: rotate(var(--rot));
      box-shadow:
        0 8px 18px rgba(0,0,0,.22),
        inset 0 10px 16px rgba(255,255,255,.10);
    }
    .drip{
      position:absolute;
      width:10px; height:22px;
      border-radius:999px;
      background: var(--splat);
      opacity:.90;
      z-index:6;
      filter: blur(.15px);
      transform-origin: top;
      animation: drip 520ms ease-out forwards;
      box-shadow: inset 0 6px 10px rgba(255,255,255,.10);
    }
    @keyframes drip{ from{ transform:scaleY(.2); opacity:0; } to{ transform:scaleY(1); opacity:.90; } }

    .particle{
      position:absolute;
      width:6px; height:6px;
      border-radius:50%;
      pointer-events:none;
      z-index:20;
      opacity:.95;
      animation: fly 430ms ease-out forwards;
      box-shadow: 0 4px 10px rgba(0,0,0,.25);
      background: var(--p);
    }
    @keyframes fly{
      to{ transform: translate(var(--dx), var(--dy)) scale(0); opacity:0; }
    }

    .attempts::-webkit-scrollbar{ width:10px; }
    .attempts::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.08);
      border-radius: 999px;
    }
    html, body {
   touch-action: manipulation;
   } 
  
   .candy {
    -webkit-user-select: none;
   user-select: none;
   -webkit-touch-callout: none;
   touch-action: none;
   }
  </style>
</head>

<body>
  <div class="bg-bubbles" id="bgBubbles"></div>

  <!-- åªä¿ç•™ 3 ä¸ªéŸ³é¢‘ï¼šsoda / pop / correct -->
  <audio id="bg-soda" preload="auto" loop></audio>
  <audio id="sfx-pop" preload="auto"></audio>
  <audio id="sfx-correct" preload="auto"></audio>

  <div class="wrap">
    <header>
      <h1>ğŸ§ƒğŸ¬ æœæ±è½¯ç³–é…å¯¹</h1>
      <div class="meta">
        <div>å…³å¡ï¼š<span id="level">1</span></div>
        <div>é…å¯¹ï¼š<span id="pairs">3</span></div>
        <div>å°è¯•ï¼š<span id="tries">0</span></div>

        <button class="btn" id="soundBtn">ğŸ”‡ å£°éŸ³å·²å…³é—­</button>
        <span id="soundDot" style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#6b7280;vertical-align:middle;"></span>

        <button class="btn" id="resetLevel">é‡ç½®æœ¬å…³</button>
        <button class="btn" id="restart">ä»ç¬¬1å…³é‡å¼€</button>
      </div>
    </header>

    <div class="panel">
      <div class="grid">
        <div class="attemptArea">
          <div class="attempts" id="attempts"></div>
        </div>

        <div class="paletteCard">
          <div class="paletteRow" id="palette"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  /* ===== èƒŒæ™¯æ³¡æ³¡ ===== */
  const bg = document.getElementById("bgBubbles");
  const BUBBLE_COUNT = 34;
  const rand = (min, max) => min + Math.random()*(max-min);
  for(let i=0;i<BUBBLE_COUNT;i++){
    const b = document.createElement("div");
    b.className = "bubble";
    const size = rand(10, 44);
    b.style.setProperty("--size", `${size}px`);
    b.style.setProperty("--x", `${rand(0, 100)}vw`);
    b.style.setProperty("--dur", `${rand(7, 16)}s`);
    b.style.setProperty("--delay", `${rand(-16, 0)}s`);
    b.style.setProperty("--sway", `${rand(2.8, 5.6)}s`);
    b.style.setProperty("--sx", `${rand(-18, 18)}px`);
    b.style.opacity = String(rand(.18, .65));
    bg.appendChild(b);
  }

  /* ===== éŸ³é¢‘ï¼šæŒ‰ä½ çš„è§„åˆ™ ===== */
  const bgSoda = document.getElementById("bg-soda");
  const sfxPop = document.getElementById("sfx-pop");
  const sfxCorrect = document.getElementById("sfx-correct");

  bgSoda.src = "soda.mp3";
  sfxPop.src = "pop.mp3";
  sfxCorrect.src = "correct.mp3";

  const VOLUME = {
    bg: 0.18,
    pop: 0.12,      // pop æ›´å°å£°
    correct: 0.35,
  };
  bgSoda.volume = VOLUME.bg;
  sfxPop.volume = VOLUME.pop;
  sfxCorrect.volume = VOLUME.correct;

  const soundBtn = document.getElementById("soundBtn");
  const soundDot = document.getElementById("soundDot");
  let audioUnlocked = false;
  let soundOn = false;

  function uiSound(){
    if (soundOn){
      soundBtn.textContent = "ğŸ”Š å£°éŸ³å·²å¼€å¯";
      soundDot.style.background = "#22c55e";
    } else {
      soundBtn.textContent = "ğŸ”‡ å£°éŸ³å·²å…³é—­";
      soundDot.style.background = "#6b7280";
    }
  }

  async function unlockOnce(){
    if (audioUnlocked) return true;
    try{
      bgSoda.muted = true;
      await bgSoda.play();
      bgSoda.pause();
      bgSoda.currentTime = 0;
      bgSoda.muted = false;
      audioUnlocked = true;
      return true;
    }catch(e){
      console.log("Audio unlock blocked:", e);
      audioUnlocked = false;
      return false;
    }
  }

  async function setSound(on){
    const ok = await unlockOnce();
    if (!ok){
      soundOn = false;
      uiSound();
      soundBtn.textContent = "âš ï¸ ç‚¹æˆ‘å¼€å¯å£°éŸ³";
      soundDot.style.background = "#ef4444";
      return;
    }

    soundOn = on;
    uiSound();

    if (soundOn){
      bgSoda.volume = VOLUME.bg;
      try{ await bgSoda.play(); }catch(e){ console.log("bg play blocked:", e); }
    } else {
      bgSoda.pause();
      bgSoda.currentTime = 0;
    }
  }

  soundBtn.addEventListener("click", async () => {
    await setSound(!soundOn);
  });
  uiSound();

  function playOne(a){
    if (!soundOn) return;
    try{
      a.currentTime = 0;
      a.play().catch(err => console.log("SFX blocked:", err));
    }catch(err){ console.log("SFX error:", err); }
  }

  /* ===== é¢œè‰²æ± ï¼ˆæ›´å¥½åŒºåˆ†ï¼‰ ===== */
  const COLOR_POOL = [
    {name:"çº¢", hex:"#ef4444"},
    {name:"æ©™", hex:"#f97316"},
    {name:"é»„", hex:"#fde047"},
    {name:"ç»¿", hex:"#16a34a"},
    {name:"é’", hex:"#22d3ee"},
    {name:"è“", hex:"#1d4ed8"},
    {name:"ç´«", hex:"#a855f7"},
    {name:"ç²‰", hex:"#fb7185"},
    {name:"æ£•", hex:"#5b341a"},
  ];

  const elLevel = document.getElementById("level");
  const elPairs = document.getElementById("pairs");
  const elTries = document.getElementById("tries");
  const elAttempts = document.getElementById("attempts");
  const elPalette = document.getElementById("palette");
  const btnResetLevel = document.getElementById("resetLevel");
  const btnRestart = document.getElementById("restart");

  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  };

  function pairsForLevel(level){
    if (level === 1) return 3;

    const base = 4 + Math.floor((level - 2) / 3);
    if (base < 7) return base;

    const first7 = 11;
    const extra = Math.floor((level - first7) / 5);
    return Math.min(7 + extra, 9);
  }

  let level = 1;
  let pairCount = 3;
  let ids = [];
  let correctSeq = [];

  let attempts = [];
  let activeRowIndex = 0;
  let draggingColorId = null;
  let draggingTouch = null;
  let touchHoverCup = null;

  document.addEventListener("touchmove", (e) => {
    if (!draggingColorId || draggingColorId == null) return;

    const t = Array.from(e.touches).find(x => x.identifier === draggingTouch.id);
    if (!t) return;
    draggingTouch.x = t.clientX;
    draggingTouch.y = t.clientY;
    
    e.preventDefault();

    const el = document.elementFromPoint(t.clientX, t.clientY);
    const cup = el ? el.closest(".cup") : null;

    if (touchHoverCup && touchHoverCup !== cup){
      touchHoverCup.classList.remove("dropHover");
    }

    if (cup) cup.classList.add("dropHover");
      touchHoverCup = cup;
    
    { passive: false }
    }
  );

  document.addEventListener("touchend", (e) => {
    if (draggingColorId == null) return;

    const t = e.changedTouches[0];
    const el = document.elementFromPoint(t.clientX, t.clientY);
    const cup = el ? el.closest(".cup") : null;

    if (touchHoverCup) touchHoverCup.classList.remove("dropHover");
    touchHoverCup = null;

   if (cup){
      const row = Number(cup.dataset.row);
      const slot = Number(cup.dataset.slot);
      if (Number.isFinite(row) && Number.isFinite(slot)){
       placeColor(row, slot, draggingColorId);
      }
    }
    draggingColorId = null;
    draggingTouch = null;
  }, { passive: false });         

 function makeCandyDiv(colorId, { inCup = false } = {}) {
   const c = COLOR_POOL[colorId];
   const d = document.createElement("div");
   d.className = "candy";
   d.dataset.colorId = String(colorId);
   d.style.background = `linear-gradient(135deg, ${c.hex}, rgba(255,255,255,.10))`;

   if (inCup) {
   d.classList.add("cupCandy");
   d.draggable = false;
   } else {
   d.classList.add("paletteCandy");
   d.draggable = true;

   // æ¡Œé¢æ‹–æ‹½ï¼ˆç”µè„‘ï¼‰
   d.addEventListener("dragstart", (e) => {
     draggingColorId = colorId;
     e.dataTransfer.setData("text/plain", String(colorId));
     e.dataTransfer.effectAllowed = "move";
   });

   d.addEventListener("dragend", () => {
     draggingColorId = null;
   });

   // âœ… è§¦å±ï¼šæ‹¿èµ·ç³–æœï¼ˆiPhoneï¼‰
   d.addEventListener(
     "touchstart",
     (e) => {
       e.preventDefault();
       const t = e.touches[0];
       draggingColorId = colorId;
       draggingTouch = { id: t.identifier, x: t.clientX, y: t.clientY };
       },
      { passive: false }
   );
}
    return d;
}

  const isRowFilled = (row) => row.guess.every(v => v !== null);

  function computeMarks(row){
    const marks = [];
    for (let i=0; i<pairCount; i++){
      marks.push(row.guess[i] === correctSeq[i]);
    }
    return marks;
  }
  const isAllCorrect = (marks) => marks.every(Boolean);

  function spawnParticles(cupEl, hex){
    const n = 12 + Math.floor(Math.random()*7);
    for (let i=0; i<n; i++){
      const p = document.createElement("div");
      p.className = "particle";
      p.style.setProperty("--p", hex);
      p.style.left = "50%";
      p.style.top = "56%";
      p.style.transform = "translate(-50%, -50%)";
      const dx = (Math.random() - 0.5) * 105;
      const dy = (Math.random() - 0.75) * 105;
      p.style.setProperty("--dx", `${dx}px`);
      p.style.setProperty("--dy", `${dy}px`);
      cupEl.appendChild(p);
      setTimeout(() => p.remove(), 460);
    }
  }

  function addSplat(cupEl, hex){
    const splat = document.createElement("div");
    splat.className = "splat";
    splat.style.setProperty("--splat", hex);
    splat.style.setProperty("--rot", `${(Math.random()*20 - 10)}deg`);
    cupEl.appendChild(splat);

    const dripCount = 1 + Math.floor(Math.random()*3);
    for(let i=0;i<dripCount;i++){
      const drip = document.createElement("div");
      drip.className = "drip";
      drip.style.setProperty("--splat", hex);
      drip.style.left = `${18 + Math.random()*54}%`;
      drip.style.top = `${56 + Math.random()*10}%`;
      drip.style.height = `${16 + Math.random()*18}px`;
      drip.style.width = `${8 + Math.random()*6}px`;
      cupEl.appendChild(drip);
    }
  }

  function placeColor(rowIdx, cupIdx, colorId){
    const row = attempts[rowIdx];
    if (!row || row.status !== "active") return;

    const prevPos = row.guess.findIndex(v => v === colorId);
    if (prevPos !== -1 && prevPos !== cupIdx){
      row.guess[prevPos] = null;
    }
    row.guess[cupIdx] = colorId;

    renderAll();

    if (isRowFilled(row)){
      const marks = computeMarks(row);
      row.marks = marks;
      row.status = isAllCorrect(marks) ? "ok" : "bad";

      if (row.status === "bad"){
        row.stains = marks.map((ok, i) => ok ? "" : COLOR_POOL[row.guess[i]].hex);

        row.residue = row.residue || Array(pairCount).fill(null);
        row.residue = row.residue.map((old, i) => {
          if (marks[i]) return old;
          return COLOR_POOL[row.guess[i]].hex;
        });

        row.burstDone = false;
        row.wrongGone = marks.map(() => false);
      }

      renderAll();

      if (row.status === "ok"){
        // å…¨å¯¹ -> æ’­ correct -> ä¸‹ä¸€å…³
        playOne(sfxCorrect);
        setTimeout(() => {
          level += 1;
          setupLevel();
        }, 620);
      } else {
        // é”™ -> æ’­ pop -> ä¸‹ä¸€è¡Œ
        playOne(sfxPop);

        setTimeout(() => {
          attempts.push({
            guess: Array(pairCount).fill(null),
            status: "active",
            residue: Array(pairCount).fill(null),
          });
          activeRowIndex = attempts.length - 1;
          renderAll();
        }, 240);
      }
    }
  }

  function setupLevel(){
    pairCount = pairsForLevel(level);

    ids = shuffle(COLOR_POOL.map((_,i)=>i)).slice(0, pairCount);
    correctSeq = shuffle(ids.slice());

    attempts = [{
      guess: Array(pairCount).fill(null),
      status: "active",
      residue: Array(pairCount).fill(null),
    }];
    activeRowIndex = 0;
    renderAll();
  }

  function resetThisLevel(){
    attempts = [{
      guess: Array(pairCount).fill(null),
      status: "active",
      residue: Array(pairCount).fill(null),
    }];
    activeRowIndex = 0;
    renderAll();
  }

  function restart(){
    level = 1;
    setupLevel();
  }

  // âœ… æ¸²æŸ“ç³–æœæ± ï¼šåªæ”¾ç³–æœï¼Œä¸æ”¾æ–‡å­—ï¼Œä¸æ”¾å¤–æ¡†å¡ç‰‡
  function renderPalette(){
    elPalette.innerHTML = "";
    const active = attempts[activeRowIndex];
    const usedSet = new Set((active?.guess ?? []).filter(v => v !== null));

    for (const colorId of ids){
      const item = document.createElement("div");
      item.className = "paletteItem";

      const candy = makeCandyDiv(colorId, {inCup:false});
      if (usedSet.has(colorId)) candy.classList.add("used");

      item.appendChild(candy);
      elPalette.appendChild(item);
    }
  }

  function renderAttempts(){
    elAttempts.innerHTML = "";

    attempts.forEach((row, idx) => {
      const card = document.createElement("div");
      card.className = "rowCard" + (idx === activeRowIndex ? " active" : "");

      const slots = document.createElement("div");
      slots.className = "slots";
      slots.dataset.count = String(pairCount);

      for (let s=0; s<pairCount; s++){
        const cup = document.createElement("div");
        cup.className = "cup";
        cup.dataset.row = String(idx);
        cup.dataset.slot = String(s);

        if (row.residue && row.residue[s]){
          const r = document.createElement("div");
          r.className = "residue";
          r.style.setProperty("--residue", row.residue[s]);
          cup.appendChild(r);
        }

        if (row.status === "active"){
          cup.addEventListener("dragover", (e) => {
            e.preventDefault();
            cup.classList.add("dropHover");
          });
          cup.addEventListener("dragleave", () => cup.classList.remove("dropHover"));
          cup.addEventListener("drop", (e) => {
            e.preventDefault();
            cup.classList.remove("dropHover");
            const data = e.dataTransfer.getData("text/plain");
            const colorId = data ? Number(data) : draggingColorId;
            if (Number.isFinite(colorId)){
              placeColor(idx, s, colorId);
            }
          });


        }


        if (row.guess[s] !== null){
          const isWrong = row.status === "bad" && row.marks && row.marks[s] === false;
          const gone = row.wrongGone && row.wrongGone[s] === true;

          if (!(isWrong && gone)){
            const candyInCup = makeCandyDiv(row.guess[s], {inCup:true});
            cup.appendChild(candyInCup);
          }
        }

        slots.appendChild(cup);
      }

      card.appendChild(slots);
      elAttempts.appendChild(card);

      // çˆ†å¼€è§†è§‰ï¼ˆä¸åœ¨è¿™é‡Œæ’­ popï¼Œpop å·²åœ¨åˆ¤é”™æ—¶æ’­è¿‡ï¼‰
      if (row.status === "bad" && row.marks && row.stains && row.burstDone === false){
        const cupEls = slots.querySelectorAll(".cup");
        // é”™è¯¯åé¦ˆï¼šä»…ç³ŠåŒ–ï¼ˆæ— å–·æº… / æ— ç²’å­ / æ—  pop åŠ¨ç”»ï¼‰
        if (row.status === "bad" && row.marks && row.burstDone === false) {
          const cupEls = slots.querySelectorAll(".cup");
          const wrongIdxs = [];
          row.marks.forEach((ok, i) => {
            if (!ok) {
              wrongIdxs.push(i);
              const candyEl = cupEls[i].querySelector(".cupCandy");
              if (candyEl) {
                candyEl.classList.add("blurWrong");
              }
            }
          });
          // ç»Ÿä¸€å»¶è¿Ÿä¸€æ¬¡æ€§å¤„ç†ï¼ˆé¿å…å¤šæ¬¡ renderï¼‰
          setTimeout(() => {
            wrongIdxs.forEach(i => {
              row.wrongGone[i] = true;
            });
            row.burstDone = true;
            renderAll();
          }, 150);
        }
      }
    });

        row.burstDone = true;
      }
    });

    elAttempts.scrollTop = elAttempts.scrollHeight;
  }

  function renderAll(){
    elLevel.textContent = String(level);
    elPairs.textContent = String(pairCount);
    elTries.textContent = String(attempts.filter(r => r.status !== "active").length);

    renderPalette();
    renderAttempts();
  }

  btnResetLevel.addEventListener("click", resetThisLevel);
  btnRestart.addEventListener("click", restart);

  setupLevel();
  if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try {
      await navigator.serviceWorker.register("./sw.js", { scope: "./" });
      console.log("SW registered");
    } catch (e) {
      console.warn("SW register failed:", e);
    }
  });
}
 document.addEventListener("touchend", (e) => {
  if (draggingColorId == null) return;

  // æ‰¾åˆ°å¯¹åº”çš„é‚£æ ¹æ‰‹æŒ‡
  const t = [...e.changedTouches].find(x => x.identifier === draggingTouchId) || e.changedTouches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);

  const cup = el && el.closest ? el.closest(".cup") : null;
  if (cup && cup.dataset && cup.dataset.row != null && cup.dataset.slot != null) {
    placeColor(Number(cup.dataset.row), Number(cup.dataset.slot), draggingColorId);
  }

  draggingColorId = null;
  draggingTouchId = null;
}, { passive: false });

})();
  .blurWrong {
  filter: blur(4px);
  opacity: 0.55;
}

</script>
</body>
</html>

