<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>å°æ˜æ±½æ°´æµæ°´çº¿</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#f0f4f8">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <style>
    :root{
      /* æ˜äº®å·¥å‚é…è‰² */
      --bg-floor: #e2e8f0;
      --bg-wall: #f8fafc;
      --text: #1e293b;
      --belt-track: #cbd5e1;
      --belt-roller: #94a3b8;
      --tray-color: #3b82f6; /* å·¥ä¸šè“å‘¨è½¬ç®± */
      --tray-dark: #1d4ed8;
      --highlight: #f59e0b; /* å®‰å…¨é»„ */
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family: system-ui, sans-serif;
      color:var(--text);
      overflow:hidden;
      background: var(--bg-floor);
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    /* ===== æ˜äº®è½¦é—´èƒŒæ™¯ ===== */
    .bg-factory{
      position:fixed; inset:0; z-index:0; pointer-events:none;
      /* åœ°æ¿çº¹ç†ï¼šæ¨¡æ‹Ÿé˜²æ»‘é’¢æ¿ */
      background-color: var(--bg-floor);
      background-image: 
        radial-gradient(#cbd5e1 15%, transparent 16%),
        radial-gradient(#cbd5e1 15%, transparent 16%);
      background-size: 20px 20px;
      background-position: 0 0, 10px 10px;
      opacity: 0.6;
    }
    /* é¡¶éƒ¨å®‰å…¨æ¡çº¹è£…é¥° */
    .bg-factory::before {
      content: "";
      position: absolute; top: 0; left: 0; right: 0; height: 12px;
      background: repeating-linear-gradient(
        45deg,
        #facc15,
        #facc15 10px,
        #1e293b 10px,
        #1e293b 20px
      );
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .wrap{ 
      width: min(1000px, 98vw); 
      height: 94vh;
      position:relative; 
      z-index:1; 
      display: flex;
      flex-direction: column;
    }

    header{
      display:flex; justify-content:space-between; align-items:center;
      padding: 12px 4px 8px 4px;
    }
    h1{ 
      margin:0; font-size:20px; font-weight: 800;
      color: #0f172a; 
      text-shadow: 2px 2px 0 #fff;
      letter-spacing: 1px;
    }
    
    .meta{ display:flex; gap:12px; font-size:14px; align-items:center; color:#475569; font-weight: bold; }
    
    /* æŒ‰é’®ï¼šå·¥ä¸šé£æ ¼ */
    .btn{
      background: linear-gradient(to bottom, #f1f5f9, #e2e8f0);
      color: #334155;
      border: 1px solid #94a3b8;
      border-bottom: 3px solid #64748b;
      padding: 6px 14px;
      font-size: 13px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      transition: all 0.1s;
    }
    .btn:active { transform: translateY(2px); border-bottom-width: 1px; }
    #restart { background: linear-gradient(to bottom, #fee2e2, #fecaca); border-color:#f87171; border-bottom-color:#ef4444; color:#991b1b; }

    /* ===== æ¸¸æˆä¸»åŒºåŸŸ ===== */
    .game-board {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 100px; 
      gap: 16px;
      overflow: hidden; 
      background: #fff; /* æ˜äº®çš„æ“ä½œå° */
      border: 4px solid #94a3b8;
      border-radius: 16px;
      padding: 12px;
      box-shadow: 
        inset 0 2px 10px rgba(0,0,0,0.05),
        0 10px 25px rgba(0,0,0,0.1);
    }

    /* === å·¦ä¾§ï¼šä¼ é€å¸¦æµæ°´çº¿ === */
    .history-viewport {
      display: flex;
      flex-direction: row;
      gap: 20px; /* å¢åŠ é—´è·ï¼Œè®©ä¼ é€å¸¦æ›´æ˜æ˜¾ */
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 10px;
      align-items: center; /* å‚ç›´å±…ä¸­ */
      scroll-behavior: smooth;
      justify-content: flex-end; 
      
      /* ğŸ­ ä¼ é€å¸¦èƒŒæ™¯ç‰¹æ•ˆ */
      background-color: #e2e8f0;
      /* ç»˜åˆ¶æ¨ªå‘çš„â€œæ»šè½´â€çº¿æ¡ */
      background-image: repeating-linear-gradient(
        to left,
        transparent,
        transparent 48px,
        rgba(0,0,0,0.05) 49px,
        rgba(0,0,0,0.05) 50px
      );
      border-radius: 8px;
      border-top: 2px solid #cbd5e1;
      border-bottom: 2px solid #cbd5e1;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
    }
    .history-viewport::-webkit-scrollbar { height: 8px; }
    .history-viewport::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 4px; }
    .history-viewport::-webkit-scrollbar-track { background: #f1f5f9; }

    /* === å³ä¾§ï¼šè´§æ¶ === */
    .shelf-column {
      background: #334155; /* æ·±è‰²è´§æ¶å¯¹æ¯” */
      border: 4px solid #1e293b;
      border-radius: 8px;
      padding: 10px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      overflow-y: auto;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
      /* é‡‘å±ç½‘æ ¼èƒŒæ™¯ */
      background-image: 
        linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
      background-size: 10px 10px;
    }
    .shelf-column::-webkit-scrollbar { width: 0; }

    /* ===== æ‰˜ç›˜ / å‘¨è½¬ç®± (Tray) ===== */
    .rowCard {
      /* å·¥ä¸šå‘¨è½¬ç®±é£æ ¼ */
      background-color: var(--tray-color);
      border: 2px solid #2563eb;
      border-bottom: 6px solid #1e40af; /* åšåº• */
      border-radius: 6px;
      padding: 8px;
      box-shadow: 
        0 10px 10px rgba(0,0,0,0.1), /* æ‚¬æµ®æ„Ÿé˜´å½± */
        inset 0 1px 0 rgba(255,255,255,0.3);
      
      display: flex;
      flex-direction: column;
      min-width: 74px;
      justify-content: center;
      transition: transform 0.3s;
      position: relative;
    }
    /* æ‰˜ç›˜ä¸¤ä¾§çš„æŠŠæ‰‹å­”ç»†èŠ‚ */
    .rowCard::before, .rowCard::after {
      content: ""; position: absolute; top: 50%; width: 4px; height: 12px;
      background: rgba(0,0,0,0.2); border-radius: 2px;
      transform: translateY(-50%);
    }
    .rowCard::before { left: 2px; }
    .rowCard::after { right: 2px; }

    /* å½“å‰æ¿€æ´»çš„æ‰˜ç›˜ï¼šé«˜äº® */
    .rowCard.active {
      background-color: #f59e0b; /* å˜ä¸ºé»„è‰² */
      border-color: #d97706;
      border-bottom-color: #b45309;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.4);
      z-index: 2;
      transform: scale(1.02);
    }
    /* æ¿€æ´»æ‰˜ç›˜æŠŠæ‰‹é¢œè‰²é€‚é… */
    .rowCard.active::before, .rowCard.active::after { background: rgba(0,0,0,0.1); }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* ===== æ ¼å­ (Slot) ===== */
    .cup {
      width: 54px; height: 68px;
      background: rgba(0,0,0,0.2); /* åŠé€æ˜é»‘ */
      border-radius: 6px;
      position: relative;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: center;
      align-items: center; 
      transition: all 0.2s;
    }
    /* æ‹–æ‹½é«˜äº® */
    .cup.dropHover { 
      background: rgba(255,255,255,0.3);
      outline: 2px dashed #fff; 
      transform: scale(1.1); 
    }
    .cup.isWrong { border: 2px solid #ef4444; background: rgba(239,68,68,0.2); }
    .cup.isCorrect { border: 2px solid #22c55e; background: rgba(34,197,94,0.1); }

    /* ===== æ˜“æ‹‰ç½ ===== */
    .can {
      width: 40px; height: 60px;
      position: relative;
      z-index: 10;
      /* æ›´åŠ é²œè‰³çš„ç“¶èº«é¢œè‰² */
      background-color: var(--can-color);
      /* å¼ºçƒˆçš„é‡‘å±å…‰æ³½ */
      background-image: 
        linear-gradient(90deg, 
          rgba(255,255,255,0.1) 0%, 
          rgba(255,255,255,0.6) 30%, 
          rgba(255,255,255,0.1) 50%,
          rgba(0,0,0,0.1) 100%);
      
      border-radius: 8px 8px 12px 12px;
      box-shadow: 2px 4px 6px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: transform 0.2s;
    }
    .can.selected {
      box-shadow: 0 0 0 3px #fff, 0 0 15px var(--highlight);
      transform: scale(1.1);
      z-index: 20;
    }
    
    .can::before {
      content: "";
      position: absolute; top: -5px; left: 4px; right: 4px; height: 6px;
      background: #e2e8f0; border-radius: 4px; border: 1px solid #94a3b8;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .can-label {
      position: absolute; top: 16px; bottom: 12px; left: 0; right: 0;
      z-index: 2;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      background-image: url('xiaoming.png'); 
      background-size: contain; 
      background-repeat: no-repeat;
      background-position: center;
    }
    
    /* æ‹–æ‹½å¹½çµ */
    .drag-ghost {
      position: fixed;
      pointer-events: none !important;
      z-index: 9999;
      transform: translate(-50%, -50%) scale(1.2) rotate(5deg);
      opacity: 0.9;
      filter: drop-shadow(0 15px 30px rgba(0,0,0,0.3));
    }

    /* çˆ†ç‚¸æ±¡æ¸ */
    .residue {
      position: absolute; inset: -5px;
      background: var(--residue-color);
      mask-image: radial-gradient(circle, black 40%, transparent 70%);
      -webkit-mask-image: radial-gradient(circle, black 40%, transparent 70%);
      opacity: 0.9; z-index: 5;
      mix-blend-mode: multiply; /* è®©æ±¡æ¸çœ‹èµ·æ¥æ¸—å…¥èƒŒæ™¯ */
      animation: splash 0.3s forwards;
    }
    @keyframes splash { 0% { transform: scale(0.2); opacity: 0; } 100% { transform: scale(1); opacity: 0.9; } }

    .paletteItem { margin-top: 8px; }
    .used .can { opacity: 0.3; filter: grayscale(1); cursor: default; box-shadow: none; }
  </style>
</head>

<body>
  <div class="bg-factory"></div>

  <audio id="bg-soda" preload="auto" loop></audio>
  <audio id="sfx-pop" preload="auto"></audio>
  <audio id="sfx-correct" preload="auto"></audio>

  <div class="wrap">
    <header>
      <div>
        <h1>ğŸ­ å°æ˜æ±½æ°´æµæ°´çº¿</h1>
        <div class="meta">
          <span>ğŸ“… ç”Ÿäº§æ‰¹æ¬¡: <b id="level">1</b></span>
          <button class="btn" id="soundBtn">ğŸ”‡</button>
        </div>
      </div>
      <div style="text-align:right">
        <button class="btn" id="resetLevel">é‡ç½®</button>
        <button class="btn" id="restart">é‡å¼€</button>
      </div>
    </header>

    <div class="game-board">
      <div class="history-viewport" id="attempts"></div>
      <div class="shelf-column" id="palette"></div>
    </div>
  </div>

<script>
(() => {
  /* ===== é…ç½® ===== */
  const COLOR_POOL = [
    {name:"è‰è“çº¢", hex:"#ef4444"}, {name:"ç”œæ©™è‰²", hex:"#f97316"}, {name:"æŸ æª¬é»„", hex:"#facc15"}, 
    {name:"é’è‹¹æœ", hex:"#22c55e"}, {name:"æµ·ç›è“", hex:"#06b6d4"}, {name:"æ·±æµ·è“", hex:"#3b82f6"}, 
    {name:"è‘¡è„ç´«", hex:"#a855f7"}, {name:"æ¡ƒå­ç²‰", hex:"#ec4899"}, {name:"æ‘©å¡æ£•", hex:"#78350f"}, 
  ];
  
  const SAVE_KEY = "xiaoming_soda_factory_v8";
  const bgSoda = document.getElementById("bg-soda");
  const sfxPop = document.getElementById("sfx-pop");
  const sfxCorrect = document.getElementById("sfx-correct");
  
  bgSoda.src = "soda.mp3"; sfxPop.src = "pop.mp3"; sfxCorrect.src = "correct.mp3";
  let soundOn = false;

  let level = 1;
  let pairCount = 3;
  let ids = [];
  let correctSeq = [];
  let attempts = [];
  let activeRowIndex = 0;

  let draggingColorId = null;
  let dragGhostEl = null;
  let selectedColorId = null;

  /* ===== å­˜æ¡£ ===== */
  function saveGame() {
    localStorage.setItem(SAVE_KEY, JSON.stringify({ level, pairCount, ids, correctSeq, attempts, activeRowIndex }));
  }
  function loadGame() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      if (!data.attempts || !data.ids) return false;
      level = data.level; pairCount = data.pairCount; ids = data.ids;
      correctSeq = data.correctSeq; attempts = data.attempts; activeRowIndex = data.activeRowIndex;
      return true;
    } catch(e) { return false; }
  }

  /* ===== é€»è¾‘ ===== */
  const shuffle = arr => arr.sort(() => Math.random() - 0.5);
  function pairsForLevel(lvl) {
    if (lvl === 1) return 3;
    const base = 4 + Math.floor((lvl - 2) / 3);
    return Math.min(base, 6); 
  }

  function setupLevel(isNew = true) {
    if (isNew) {
      pairCount = pairsForLevel(level);
      const pool = COLOR_POOL.map((_, i) => i);
      ids = shuffle(pool).slice(0, pairCount);
      correctSeq = shuffle([...ids]);
      attempts = [{
        guess: Array(pairCount).fill(null), status: "active", residue: Array(pairCount).fill(null)
      }];
      activeRowIndex = 0;
      selectedColorId = null;
    }
    saveGame();
    renderAll();
    setTimeout(scrollToEnd, 100);
  }

  function placeColor(rowIdx, cupIdx, colorId) {
    const row = attempts[rowIdx];
    if (!row || row.status !== "active") return;
    const existIdx = row.guess.indexOf(colorId);
    if (existIdx !== -1 && existIdx !== cupIdx) row.guess[existIdx] = null;
    row.guess[cupIdx] = colorId;
    
    selectedColorId = null; // æ”¾ä¸‹åå–æ¶ˆé€‰ä¸­
    saveGame();
    renderAll();
    if (row.guess.every(v => v !== null)) checkRow(row);
  }

  function checkRow(row) {
    const marks = row.guess.map((id, i) => id === correctSeq[i]);
    const allCorrect = marks.every(Boolean);
    row.marks = marks;
    row.status = allCorrect ? "ok" : "bad";

    if (!allCorrect) {
      row.residue = row.guess.map((id, i) => marks[i] ? null : COLOR_POOL[id].hex);
      playSound(sfxPop);
    } else {
      playSound(sfxCorrect);
    }
    saveGame();
    renderAll();
    
    if (allCorrect) {
      setTimeout(() => { level++; setupLevel(true); }, 1200);
    } else {
      setTimeout(() => {
        // æ–°å¢ä¸€ä¸ªå‘¨è½¬ç®±
        attempts.push({
          guess: Array(pairCount).fill(null), status: "active", residue: Array(pairCount).fill(null)
        });
        activeRowIndex++;
        saveGame();
        renderAll();
        // æ ¸å¿ƒåŠ¨ç”»ï¼šæ–°çš„ç®±å­å‡ºç°åœ¨å³ä¾§ï¼Œæ—§çš„å‘å·¦æ»šåŠ¨ï¼ˆä¼ é€å¸¦æ•ˆæœï¼‰
        scrollToEnd(); 
      }, 600);
    }
  }

  /* ===== æ¸²æŸ“ ===== */
  const elAttempts = document.getElementById("attempts");
  const elPalette = document.getElementById("palette");

  function scrollToEnd() {
    elAttempts.scrollTo({ left: elAttempts.scrollWidth, behavior: 'smooth' });
  }

  function createCanHTML(colorId) {
    const hex = COLOR_POOL[colorId].hex;
    return `<div class="can" style="--can-color:${hex}"><div class="can-label"></div></div>`;
  }

  function renderPalette() {
    elPalette.innerHTML = "";
    const activeRow = attempts[activeRowIndex];
    const usedIds = new Set(activeRow ? activeRow.guess.filter(x => x !== null) : []);

    ids.forEach(id => {
      const wrap = document.createElement("div");
      wrap.className = "paletteItem";
      if (usedIds.has(id)) wrap.classList.add("used");
      
      const canDiv = document.createElement("div");
      canDiv.innerHTML = createCanHTML(id);
      const canEl = canDiv.firstElementChild;
      if (selectedColorId === id) canEl.classList.add("selected");

      addInteraction(canEl, id, false); 
      wrap.appendChild(canEl);
      elPalette.appendChild(wrap);
    });
  }

  function renderAttempts() {
    elAttempts.innerHTML = "";
    attempts.forEach((row, rIdx) => {
      const isLast = rIdx === activeRowIndex;
      const card = document.createElement("div");
      card.className = "rowCard" + (isLast ? " active" : "");
      
      const slots = document.createElement("div");
      slots.className = "slots";

      for (let i = 0; i < pairCount; i++) {
        const cup = document.createElement("div");
        cup.className = "cup";
        cup.dataset.r = rIdx;
        cup.dataset.c = i;

        // ç‚¹å‡»æ”¾ç½®æç¤º
        if (isLast && selectedColorId !== null && row.guess[i] === null) {
          cup.style.outline = "2px dashed #f59e0b";
          cup.style.background = "rgba(255,255,255,0.5)";
        } else {
          cup.style.outline = "";
          cup.style.background = "";
        }

        cup.onclick = () => {
          if (isLast && selectedColorId !== null) {
            placeColor(rIdx, i, selectedColorId);
          }
        };

        if (row.residue && row.residue[i]) {
          const s = document.createElement("div");
          s.className = "residue";
          s.style.setProperty("--residue-color", row.residue[i]);
          cup.appendChild(s);
          cup.classList.add("isWrong");
        }

        const cid = row.guess[i];
        if (cid !== null) {
          const isCorrect = row.marks && row.marks[i];
          const isFinished = row.status !== "active";
          if (!isFinished || isCorrect) {
            const canWrap = document.createElement("div");
            canWrap.innerHTML = createCanHTML(cid);
            const canEl = canWrap.firstElementChild;
            addInteraction(canEl, cid, true); 
            cup.appendChild(canEl);
            if (isFinished && isCorrect) cup.classList.add("isCorrect");
          }
        }
        slots.appendChild(cup);
      }
      card.appendChild(slots);
      elAttempts.appendChild(card);
    });
  }

  function renderAll() {
    document.getElementById("level").innerText = level;
    renderPalette();
    renderAttempts();
  }

  /* ===== äº¤äº’ï¼šç‚¹å‡»+æ‹–æ‹½ ===== */
  function addInteraction(el, colorId, inGrid) {
    let startX = 0, startY = 0;
    let hasMoved = false;

    const start = (x, y) => {
      startX = x; startY = y;
      hasMoved = false;
      draggingColorId = colorId;
      setTimeout(() => { if (hasMoved) createGhost(x, y, colorId); }, 50);
    };

    const move = (x, y) => {
      if (Math.abs(x - startX) > 5 || Math.abs(y - startY) > 5) {
        hasMoved = true;
        if (!dragGhostEl) createGhost(x, y, colorId);
        moveGhost(x, y);
        highlightCup(x, y);
      }
    };

    const end = (x, y) => {
      if (hasMoved && dragGhostEl) {
        dropAt(x, y);
      } else if (!hasMoved) {
        if (!inGrid) { 
           if (selectedColorId === colorId) selectedColorId = null;
           else { selectedColorId = colorId; playSound(bgSoda); }
           renderAll();
        } else {
           selectedColorId = colorId;
           renderAll();
        }
      }
      removeGhost();
    };

    el.addEventListener("touchstart", e => start(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
    el.addEventListener("touchmove", e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    el.addEventListener("touchend", e => end(e.changedTouches[0].clientX, e.changedTouches[0].clientY));

    el.addEventListener("mousedown", e => {
      start(e.clientX, e.clientY);
      const onMove = ev => move(ev.clientX, ev.clientY);
      const onUp = ev => {
        end(ev.clientX, ev.clientY);
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    });
  }

  function createGhost(x, y, cid) {
    if (dragGhostEl) return;
    const div = document.createElement("div");
    div.innerHTML = createCanHTML(cid);
    const ghost = div.firstElementChild;
    ghost.classList.add("drag-ghost");
    document.body.appendChild(ghost);
    dragGhostEl = ghost;
    moveGhost(x, y);
  }

  function moveGhost(x, y) {
    if (dragGhostEl) { dragGhostEl.style.left = x + "px"; dragGhostEl.style.top = y + "px"; }
  }

  function removeGhost() {
    if (dragGhostEl) { dragGhostEl.remove(); dragGhostEl = null; }
    draggingColorId = null;
    clearHighlight();
  }

  function getClosestActiveCup(x, y) {
    const activeCups = Array.from(document.querySelectorAll('.rowCard.active .cup'));
    let closest = null, min = 100;
    activeCups.forEach(cup => {
      const rect = cup.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const d = Math.hypot(x - cx, y - cy);
      if (d < min) { min = d; closest = cup; }
    });
    return closest;
  }

  function highlightCup(x, y) {
    clearHighlight();
    const cup = getClosestActiveCup(x, y);
    if (cup) cup.classList.add("dropHover");
  }

  function clearHighlight() {
    document.querySelectorAll(".dropHover").forEach(e => e.classList.remove("dropHover"));
  }

  function dropAt(x, y) {
    const cup = getClosestActiveCup(x, y);
    if (cup) {
      const r = parseInt(cup.dataset.r);
      const c = parseInt(cup.dataset.c);
      placeColor(r, c, draggingColorId);
    }
  }

  /* ===== å£°éŸ³ ===== */
  const soundBtn = document.getElementById("soundBtn");
  soundBtn.onclick = () => {
    soundOn = !soundOn;
    soundBtn.innerText = soundOn ? "ğŸ”Š" : "ğŸ”‡";
    bgSoda.volume = soundOn ? 0.2 : 0;
    if (soundOn) bgSoda.play().catch(()=>{}); else bgSoda.pause();
  };
  function playSound(a) { if (soundOn) { a.currentTime=0; a.play().catch(()=>{}); } }

  document.getElementById("resetLevel").onclick = () => setupLevel(true);
  document.getElementById("restart").onclick = () => { localStorage.removeItem(SAVE_KEY); level = 1; setupLevel(true); };

  if (!loadGame()) setupLevel(true); else { renderAll(); setTimeout(scrollToEnd, 200); }
})();
</script>
</body>
</html>
