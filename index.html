<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>æ±½æ°´çŒè£…å‚</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#2e2e2e">
  <link rel="apple-touch-icon" sizes="152x152" href="icon-152.png">
  <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <style>
    :root{
      --text: #f3f4f6;
      --wood-base: #5d4037;
      --wood-dark: #3e2723;
    }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      font-family: system-ui, sans-serif;
      color:var(--text);
      overflow:hidden;
      background: #1a1a1a;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ===== èƒŒæ™¯è£…é¥° ===== */
    .bg-factory{
      position:fixed; inset:0; z-index:0; pointer-events:none;
      background: 
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px),
        radial-gradient(circle at 80% 20%, #333, #111);
    }

    /* ===== ä¸»å®¹å™¨ ===== */
    .wrap{ 
      width: min(1000px, 98vw); 
      height: 94vh;
      position:relative; 
      z-index:1; 
      display: flex;
      flex-direction: column;
    }

    header{
      display:flex; justify-content:space-between; align-items:center;
      padding: 0 4px 8px 4px;
    }
    h1{ margin:0; font-size:18px; color: #fbbf24; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    
    .meta{ display:flex; gap:12px; font-size:13px; align-items:center; color:#ccc; }
    .btn{
      background: linear-gradient(to bottom, #5d4037, #3e2723);
      color: #e0e0e0;
      border: 1px solid #795548;
      border-bottom: 2px solid #281a16;
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    .btn:active { transform: translateY(1px); border-bottom-width: 1px; }

    /* ===== æ¸¸æˆæ ¸å¿ƒåŒº (Grid) ===== */
    .game-board {
      flex: 1;
      display: grid;
      /* å†å²åŒº(è‡ªé€‚åº”) | è´§æ¶(å›ºå®š) */
      grid-template-columns: 1fr 96px; 
      gap: 16px;
      overflow: hidden; 
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 12px;
      box-shadow: inset 0 0 30px rgba(0,0,0,0.6);
    }

    /* --- å·¦ä¾§ï¼šä¼ é€å¸¦åŒºåŸŸ (History) --- */
    .history-viewport {
      display: flex;
      flex-direction: row;
      gap: 12px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 10px;
      align-items: stretch;
      scroll-behavior: smooth; /* å¹³æ»‘æ»šåŠ¨ */
    }
    .history-viewport::-webkit-scrollbar { height: 6px; }
    .history-viewport::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

    /* --- å³ä¾§ï¼šè´§æ¶ (Shelf) --- */
    .shelf-column {
      background: #2b1d1a;
      border: 4px solid #1a100d;
      border-radius: 8px;
      padding: 10px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      overflow-y: auto;
      box-shadow: inset 0 0 10px #000;
      /* æœ¨çº¹è´§æ¶èƒŒæ™¯ */
      background-image: repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 1px, transparent 20px);
    }
    .shelf-column::-webkit-scrollbar { width: 0; }

    /* ===== æ¯ä¸€åˆ— (Column Card) ===== */
    .rowCard {
      /* é«˜çº§æœ¨çº¹ */
      background-color: #4e342e;
      background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%232d1d18' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M0 0h40v40H0V0zm20 20h20v20H20V20zM0 20h20v20H0V20zM20 0h20v20H20V0z'/%3E%3C/g%3E%3C/svg%3E");
      
      border: 2px solid #3e2723;
      border-right: 4px solid #281a16; /* å³ä¾§åŠ åšï¼Œäº§ç”Ÿç«‹ä½“æ„Ÿ */
      border-bottom: 4px solid #281a16;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      
      display: flex;
      flex-direction: column;
      min-width: 64px;
      justify-content: center;
      transition: transform 0.3s;
    }
    .rowCard.active {
      border-color: #fbbf24;
      background-color: #5d4037;
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.2);
      transform: scale(1.02); /* å½“å‰åˆ—ç¨å¾®å¤§ä¸€ç‚¹ */
    }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* ===== æ ¼å­ (Grid Cell) ===== */
    .cup {
      width: 48px; height: 60px; /* æ ¼å­é«˜åº¦ */
      background: #261613;
      border-radius: 4px;
      position: relative;
      /* å†…é™·æ„Ÿ */
      box-shadow: inset 0 3px 8px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.05);
      border: 1px solid #3e2723;
      display: flex;
      justify-content: center;
      align-items: center; 
    }
    .cup.dropHover { 
      background: #3e2a26; 
      outline: 2px dashed #fbbf24; 
    }
    .cup.isWrong { border: 2px solid #ef4444; }
    .cup.isCorrect { border: 2px solid #22c55e; }

    /* ===== æ˜“æ‹‰ç½ (Soda Can) ===== */
    .can {
      width: 34px; height: 52px;
      position: relative;
      z-index: 10;
      /* é‡‘å±ç½èº« */
      background: linear-gradient(90deg, #9ca3af 0%, #e5e7eb 40%, #9ca3af 100%);
      border-radius: 6px 6px 10px 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.4);
      cursor: grab;
    }
    
    /* ç½å­é¡¶éƒ¨è½®å»“ */
    .can::before {
      content: "";
      position: absolute;
      top: -3px; left: 2px; right: 2px; height: 6px;
      background: #d1d5db;
      border-radius: 4px;
      border: 1px solid #9ca3af;
    }

    /* ç™½è‰²æ ‡ç­¾å¸¦ */
    .can-label {
      position: absolute;
      top: 12px; bottom: 12px; 
      left: 0; right: 0;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2;
    }
    
    /* ä¸­é—´çš„é¢œè‰²æ ‡ (Logo) */
    .can-logo {
      width: 22px; height: 22px;
      background-color: var(--can-color);
      border-radius: 50%;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      border: 2px solid white;
    }

    /* æ‹–æ‹½æ—¶çš„å¹½çµå…ƒç´  */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 999;
      transform: translate(-50%, -50%) scale(1.1);
      opacity: 0.9;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
    }

    /* ===== çˆ†ç‚¸æ±¡æ¸ ===== */
    .residue {
      position: absolute;
      inset: -5px;
      background: var(--residue-color);
      mask-image: radial-gradient(circle, black 30%, transparent 70%);
      -webkit-mask-image: radial-gradient(circle, black 30%, transparent 70%);
      opacity: 0.9;
      z-index: 5;
      animation: splash 0.3s ease-out forwards;
    }
    @keyframes splash {
      0% { transform: scale(0.5); opacity: 0; }
      100% { transform: scale(1.2); opacity: 0.9; }
    }

    .paletteItem { margin-top: 5px; }
    .used .can { opacity: 0.3; filter: grayscale(1); cursor: default; }

  </style>
</head>

<body>
  <div class="bg-factory"></div>

  <audio id="bg-soda" preload="auto" loop></audio>
  <audio id="sfx-pop" preload="auto"></audio>
  <audio id="sfx-correct" preload="auto"></audio>

  <div class="wrap">
    <header>
      <div>
        <h1>ğŸ­ æ±½æ°´æµæ°´çº¿</h1>
        <div class="meta">
          <span>Level: <b id="level">1</b></span>
          <button class="btn" id="soundBtn">ğŸ”‡</button>
        </div>
      </div>
      <div style="text-align:right">
        <button class="btn" id="resetLevel">é‡ç½®æœ¬å…³</button>
        <button class="btn" id="restart" style="background:#8c2f2f; border-color:#5c1e1e;">é‡æ–°å¼€å§‹</button>
      </div>
    </header>

    <div class="game-board">
      <div class="history-viewport" id="attempts"></div>
      
      <div class="shelf-column" id="palette"></div>
    </div>
  </div>

<script>
(() => {
  /* ===== æ ¸å¿ƒé…ç½® ===== */
  const COLOR_POOL = [
    {name:"å¯ä¹çº¢", hex:"#dc2626"}, 
    {name:"èŠ¬è¾¾æ©™", hex:"#ea580c"}, 
    {name:"æŸ æª¬é»„", hex:"#eab308"}, 
    {name:"é›ªç¢§ç»¿", hex:"#16a34a"}, 
    {name:"æµ·ç›é’", hex:"#06b6d4"}, 
    {name:"ç™¾äº‹è“", hex:"#2563eb"}, 
    {name:"è‘¡è„ç´«", hex:"#9333ea"}, 
    {name:"æ¡ƒå­ç²‰", hex:"#db2777"}, 
    {name:"å’–å•¡æ£•", hex:"#5d4037"}, 
  ];
  
  const SAVE_KEY = "soda_factory_v3";
  
  // éŸ³é¢‘
  const bgSoda = document.getElementById("bg-soda");
  const sfxPop = document.getElementById("sfx-pop");
  const sfxCorrect = document.getElementById("sfx-correct");
  bgSoda.src = "soda.mp3"; sfxPop.src = "pop.mp3"; sfxCorrect.src = "correct.mp3";
  let soundOn = false;

  // çŠ¶æ€å˜é‡
  let level = 1;
  let pairCount = 3;
  let ids = [];
  let correctSeq = [];
  let attempts = [];
  let activeRowIndex = 0;

  // æ‹–æ‹½å˜é‡
  let draggingColorId = null;
  let dragGhostEl = null;

  /* ===== å­˜æ¡£é€»è¾‘ ===== */
  function saveGame() {
    localStorage.setItem(SAVE_KEY, JSON.stringify({
      level, pairCount, ids, correctSeq, attempts, activeRowIndex
    }));
  }

  function loadGame() {
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      if (!data.attempts || !data.ids) return false;
      
      level = data.level;
      pairCount = data.pairCount;
      ids = data.ids;
      correctSeq = data.correctSeq;
      attempts = data.attempts;
      activeRowIndex = data.activeRowIndex;
      return true;
    } catch(e) { return false; }
  }

  /* ===== æ¸¸æˆé€»è¾‘ ===== */
  const shuffle = arr => arr.sort(() => Math.random() - 0.5);

  function pairsForLevel(lvl) {
    if (lvl === 1) return 3;
    const base = 4 + Math.floor((lvl - 2) / 3);
    return Math.min(base, 6); // ç«–æ’ä¸è¦å¤ªé«˜ï¼Œé™åˆ¶6ä¸ª
  }

  function setupLevel(isNew = true) {
    if (isNew) {
      pairCount = pairsForLevel(level);
      const pool = COLOR_POOL.map((_, i) => i);
      ids = shuffle(pool).slice(0, pairCount);
      correctSeq = shuffle([...ids]);

      attempts = [{
        guess: Array(pairCount).fill(null),
        status: "active",
        residue: Array(pairCount).fill(null)
      }];
      activeRowIndex = 0;
    }
    saveGame();
    renderAll();
    setTimeout(scrollToEnd, 100);
  }

  function placeColor(rowIdx, cupIdx, colorId) {
    const row = attempts[rowIdx];
    if (!row || row.status !== "active") return;

    // å”¯ä¸€æ€§ï¼šå¦‚æœè¯¥è‰²å·²åœ¨å½“å‰åˆ—ï¼Œå…ˆç§»é™¤
    const existIdx = row.guess.indexOf(colorId);
    if (existIdx !== -1 && existIdx !== cupIdx) row.guess[existIdx] = null;

    row.guess[cupIdx] = colorId;
    saveGame();
    renderAll();

    if (row.guess.every(v => v !== null)) checkRow(row);
  }

  function checkRow(row) {
    const marks = row.guess.map((id, i) => id === correctSeq[i]);
    const allCorrect = marks.every(Boolean);

    row.marks = marks;
    row.status = allCorrect ? "ok" : "bad";

    // é”™è¯¯å¤„ç†ï¼šè®°å½•æ±¡æ¸
    if (!allCorrect) {
      row.residue = row.guess.map((id, i) => marks[i] ? null : COLOR_POOL[id].hex);
      playSound(sfxPop);
    } else {
      playSound(sfxCorrect);
    }

    saveGame();
    renderAll();
    
    // å»¶è¿Ÿæ“ä½œ
    if (allCorrect) {
      setTimeout(() => { level++; setupLevel(true); }, 1200);
    } else {
      setTimeout(() => {
        // æ–°å¢ä¸€åˆ—ï¼Œactive indexå¢åŠ 
        attempts.push({
          guess: Array(pairCount).fill(null),
          status: "active",
          residue: Array(pairCount).fill(null)
        });
        activeRowIndex++;
        saveGame();
        renderAll();
        // è‡ªåŠ¨æ»šåˆ°æœ€å³ä¾§ï¼Œè§†è§‰ä¸Šåƒæ—§çš„å¾€å·¦ç§»äº†
        scrollToEnd(); 
      }, 600);
    }
  }

  /* ===== æ¸²æŸ“é€»è¾‘ ===== */
  const elAttempts = document.getElementById("attempts");
  const elPalette = document.getElementById("palette");

  function scrollToEnd() {
    elAttempts.scrollTo({ left: elAttempts.scrollWidth, behavior: 'smooth' });
  }

  // åˆ›å»ºæ˜“æ‹‰ç½ DOM
  function createCanHTML(colorId) {
    const hex = COLOR_POOL[colorId].hex;
    // æ˜“æ‹‰ç½ç»“æ„ï¼šä¸»ä½“ -> æ ‡ç­¾å¸¦ -> é¢œè‰²Logo
    return `
      <div class="can" style="--can-color:${hex}">
        <div class="can-label">
          <div class="can-logo"></div>
        </div>
      </div>
    `;
  }

  function renderPalette() {
    elPalette.innerHTML = "";
    const activeRow = attempts[activeRowIndex];
    const usedIds = new Set(activeRow ? activeRow.guess.filter(x => x !== null) : []);

    ids.forEach(id => {
      const wrap = document.createElement("div");
      wrap.className = "paletteItem";
      if (usedIds.has(id)) wrap.classList.add("used");

      // åŒ…è£…ä¸€ä¸ªå¯äº¤äº’å®¹å™¨
      const canDiv = document.createElement("div");
      canDiv.innerHTML = createCanHTML(id);
      const canEl = canDiv.firstElementChild;

      // ç»‘å®šè§¦æ‘¸äº‹ä»¶
      addDragLogic(canEl, id);

      wrap.appendChild(canEl);
      elPalette.appendChild(wrap);
    });
  }

  function renderAttempts() {
    elAttempts.innerHTML = "";
    attempts.forEach((row, rIdx) => {
      const isLast = rIdx === activeRowIndex;
      const card = document.createElement("div");
      card.className = "rowCard" + (isLast ? " active" : "");
      
      const slots = document.createElement("div");
      slots.className = "slots";

      for (let i = 0; i < pairCount; i++) {
        const cup = document.createElement("div");
        cup.className = "cup";
        cup.dataset.r = rIdx;
        cup.dataset.c = i;

        // 1. æ±¡æ¸
        if (row.residue && row.residue[i]) {
          const s = document.createElement("div");
          s.className = "residue";
          s.style.setProperty("--residue-color", row.residue[i]);
          cup.appendChild(s);
          cup.classList.add("isWrong");
        }

        // 2. æ˜“æ‹‰ç½
        const cid = row.guess[i];
        if (cid !== null) {
          const isCorrect = row.marks && row.marks[i];
          const isFinished = row.status !== "active";
          
          // å¦‚æœç»“æŸäº†ï¼Œåªæ˜¾ç¤ºæ­£ç¡®çš„ï¼›æˆ–è€…è¿˜æ²¡ç»“æŸæ˜¾ç¤ºæ‰€æœ‰
          if (!isFinished || isCorrect) {
            const canWrap = document.createElement("div");
            canWrap.innerHTML = createCanHTML(cid);
            const canEl = canWrap.firstElementChild;
            // å·²ç»åœ¨æ ¼å­é‡Œäº†ï¼Œä¸éœ€è¦æ‹–æ‹½é€»è¾‘ï¼Œé™¤éä½ æƒ³æŠŠç“¶å­æ‹¿å‡ºæ¥ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºä¸å¯æ‹¿å‡ºï¼‰
            cup.appendChild(canEl);
            if (isFinished && isCorrect) cup.classList.add("isCorrect");
          }
        }

        // 3. æ”¾ç½®åŒºåŸŸäº¤äº’
        if (row.status === "active") {
           // å…è®¸æ”¾ä¸‹
           // ç®€å•çš„ç‚¹å‡»æ”¾ç½®é€»è¾‘ (å¤‡ç”¨) æˆ– æ‹–æ‹½å“åº”
        }

        slots.appendChild(cup);
      }
      card.appendChild(slots);
      elAttempts.appendChild(card);
    });
  }

  function renderAll() {
    document.getElementById("level").innerText = level;
    renderPalette();
    renderAttempts();
  }

  /* ===== æ‹–æ‹½ç³»ç»Ÿ (Mouse & Touch ç»Ÿä¸€è·Ÿéš) ===== */
  function addDragLogic(el, colorId) {
    
    // --- Touch ---
    el.addEventListener("touchstart", e => {
      e.preventDefault(); // é˜»æ­¢æ»šåŠ¨
      draggingColorId = colorId;
      const touch = e.touches[0];
      createGhost(touch.clientX, touch.clientY, colorId);
    }, {passive: false});

    el.addEventListener("touchmove", e => {
      e.preventDefault();
      if (!dragGhostEl) return;
      const touch = e.touches[0];
      moveGhost(touch.clientX, touch.clientY);
      highlightCup(touch.clientX, touch.clientY);
    }, {passive: false});

    el.addEventListener("touchend", e => {
      const touch = e.changedTouches[0];
      dropAt(touch.clientX, touch.clientY);
      removeGhost();
    });

    // --- Mouse ---
    el.addEventListener("mousedown", e => {
      draggingColorId = colorId;
      createGhost(e.clientX, e.clientY, colorId);
      
      const onMove = ev => {
        moveGhost(ev.clientX, ev.clientY);
        highlightCup(ev.clientX, ev.clientY);
      };
      const onUp = ev => {
        dropAt(ev.clientX, ev.clientY);
        removeGhost();
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    });
  }

  function createGhost(x, y, cid) {
    removeGhost();
    const div = document.createElement("div");
    div.innerHTML = createCanHTML(cid);
    const ghost = div.firstElementChild;
    ghost.classList.add("drag-ghost");
    document.body.appendChild(ghost);
    dragGhostEl = ghost;
    moveGhost(x, y);
  }

  function moveGhost(x, y) {
    if (dragGhostEl) {
      dragGhostEl.style.left = x + "px";
      dragGhostEl.style.top = y + "px";
    }
  }

  function removeGhost() {
    if (dragGhostEl) {
      dragGhostEl.remove();
      dragGhostEl = null;
    }
    draggingColorId = null;
    clearHighlight();
  }

  function highlightCup(x, y) {
    clearHighlight();
    const cup = getCupAt(x, y);
    if (cup && isCupActive(cup)) {
      cup.classList.add("dropHover");
    }
  }

  function clearHighlight() {
    document.querySelectorAll(".dropHover").forEach(e => e.classList.remove("dropHover"));
  }

  function dropAt(x, y) {
    const cup = getCupAt(x, y);
    if (cup && isCupActive(cup)) {
      const r = parseInt(cup.dataset.r);
      const c = parseInt(cup.dataset.c);
      placeColor(r, c, draggingColorId);
    }
  }

  function getCupAt(x, y) {
    const el = document.elementFromPoint(x, y);
    return el ? el.closest(".cup") : null;
  }

  function isCupActive(cup) {
    const r = parseInt(cup.dataset.r);
    return attempts[r] && attempts[r].status === "active";
  }

  /* ===== å£°éŸ³ ===== */
  const soundBtn = document.getElementById("soundBtn");
  soundBtn.onclick = () => {
    soundOn = !soundOn;
    soundBtn.innerText = soundOn ? "ğŸ”Š" : "ğŸ”‡";
    bgSoda.volume = soundOn ? 0.2 : 0;
    if (soundOn) bgSoda.play().catch(()=>{});
    else bgSoda.pause();
  };

  function playSound(a) {
    if (soundOn) { a.currentTime=0; a.play().catch(()=>{}); }
  }

  /* ===== Init ===== */
  document.getElementById("resetLevel").onclick = () => setupLevel(true);
  document.getElementById("restart").onclick = () => {
    localStorage.removeItem(SAVE_KEY);
    level = 1; setupLevel(true);
  };

  if (!loadGame()) setupLevel(true);
  else {
    renderAll();
    setTimeout(scrollToEnd, 200);
  }

})();
</script>
</body>
</html>
